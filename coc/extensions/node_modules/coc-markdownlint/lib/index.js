var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS((exports2, module2) => {
  /*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  "use strict";
  function isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
  }
  function cloneSpecificValue(val) {
    if (val instanceof Buffer) {
      var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
      val.copy(x);
      return x;
    } else if (val instanceof Date) {
      return new Date(val.getTime());
    } else if (val instanceof RegExp) {
      return new RegExp(val);
    } else {
      throw new Error("Unexpected situation");
    }
  }
  function deepCloneArray(arr) {
    var clone = [];
    arr.forEach(function(item, index) {
      if (typeof item === "object" && item !== null) {
        if (Array.isArray(item)) {
          clone[index] = deepCloneArray(item);
        } else if (isSpecificValue(item)) {
          clone[index] = cloneSpecificValue(item);
        } else {
          clone[index] = deepExtend({}, item);
        }
      } else {
        clone[index] = item;
      }
    });
    return clone;
  }
  function safeGetProperty(object, property) {
    return property === "__proto__" ? void 0 : object[property];
  }
  var deepExtend = module2.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] !== "object") {
      return false;
    }
    if (arguments.length < 2) {
      return arguments[0];
    }
    var target = arguments[0];
    var args = Array.prototype.slice.call(arguments, 1);
    var val, src, clone;
    args.forEach(function(obj) {
      if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return;
      }
      Object.keys(obj).forEach(function(key) {
        src = safeGetProperty(target, key);
        val = safeGetProperty(obj, key);
        if (val === target) {
          return;
        } else if (typeof val !== "object" || val === null) {
          target[key] = val;
          return;
        } else if (Array.isArray(val)) {
          target[key] = deepCloneArray(val);
          return;
        } else if (isSpecificValue(val)) {
          target[key] = cloneSpecificValue(val);
          return;
        } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
          target[key] = deepExtend({}, val);
          return;
        } else {
          target[key] = deepExtend(src, val);
          return;
        }
      });
    });
    return target;
  };
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS((exports2, module2) => {
  "use strict";
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend2(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  module2.exports.isNothing = isNothing;
  module2.exports.isObject = isObject;
  module2.exports.toArray = toArray;
  module2.exports.repeat = repeat;
  module2.exports.isNegativeZero = isNegativeZero;
  module2.exports.extend = extend2;
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS((exports2, module2) => {
  "use strict";
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
      result += " " + this.mark.toString();
    }
    return result;
  };
  module2.exports = YAMLException;
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    tail = "";
    end = this.position;
    while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
  };
  Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += ":\n" + snippet;
      }
    }
    return where;
  };
  module2.exports = Mark;
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS((exports2, module2) => {
  "use strict";
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  module2.exports = Type;
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  var YAMLException = require_exception();
  var Type = require_type();
  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type) {
      result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  Schema.DEFAULT = null;
  Schema.create = function createSchema() {
    var schemas, types;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas = common.toArray(schemas);
    types = common.toArray(types);
    if (!schemas.every(function(schema) {
      return schema instanceof Schema;
    })) {
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
      return type instanceof Type;
    })) {
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema({
      include: schemas,
      explicit: types
    });
  };
  module2.exports = Schema;
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  module2.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  module2.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  var Type = require_type();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "_")
      return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (ch === ":")
        break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    if (ch !== ":")
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  module2.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  var Type = require_type();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    } else if (value.indexOf(":") >= 0) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  module2.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_failsafe()
    ],
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_json()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  module2.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  module2.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS((exports2, module2) => {
  "use strict";
  var NodeBuffer;
  try {
    _require = require;
    NodeBuffer = _require("buffer").Buffer;
  } catch (__) {
  }
  var _require;
  var Type = require_type();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    } else if (tail === 2) {
      result += map[bits >> 10 & 63];
      result += map[bits >> 4 & 63];
      result += map[bits << 2 & 63];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 63];
      result += map[bits << 4 & 63];
      result += map[64];
      result += map[64];
    }
    return result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  module2.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  module2.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  module2.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  module2.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_core()
    ],
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return void 0;
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object === "undefined";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp[regexp.length - modifiers.length - 1] !== "/")
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    if (object.global)
      result += "g";
    if (object.multiline)
      result += "m";
    if (object.ignoreCase)
      result += "i";
    return result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS((exports2, module2) => {
  "use strict";
  var esprima;
  try {
    _require = require;
    esprima = _require("esprima");
  } catch (_) {
    if (typeof window !== "undefined")
      esprima = window.esprima;
  }
  var _require;
  var Type = require_type();
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = "(" + data + ")", ast = esprima.parse(source, {range: true});
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = "(" + data + ")", ast = esprima.parse(source, {range: true}), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
      throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    if (ast.body[0].expression.body.type === "BlockStatement") {
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    return new Function(params, "return " + source.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = Schema.DEFAULT = new Schema({
    include: [
      require_default_safe()
    ],
    explicit: [
      require_undefined(),
      require_regexp(),
      require_function()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  var YAMLException = require_exception();
  var Mark = require_mark();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== "!") {
      if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type = state.typeMap[state.kind || "fallback"][state.tag];
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  function safeLoadAll(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    return loadAll(input, iterator, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
  }
  function safeLoad(input, options) {
    return load(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
  }
  module2.exports.loadAll = loadAll;
  module2.exports.load = load;
  module2.exports.safeLoadAll = safeLoadAll;
  module2.exports.safeLoad = safeLoad;
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common();
  var YAMLException = require_exception();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null)
      return {};
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type = schema.compiledTypeMap["fallback"][tag];
      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  function State(options) {
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
  }
  function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev) {
    return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char >= 55296 && char <= 56319) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 56320 && nextChar <= 57343) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
          i++;
          continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0)
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (index !== 0)
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        state.tag = explicit ? type.tag : "?";
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString.call(type.represent) === "[object Function]") {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        if (block && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type);
      }
      if (state.tag !== null && state.tag !== "?") {
        state.dump = "!<" + state.tag + "> " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + "\n";
    return "";
  }
  function safeDump(input, options) {
    return dump(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
  }
  module2.exports.dump = dump;
  module2.exports.safeDump = safeDump;
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS((exports2, module2) => {
  "use strict";
  var loader = require_loader();
  var dumper = require_dumper();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  module2.exports.Type = require_type();
  module2.exports.Schema = require_schema();
  module2.exports.FAILSAFE_SCHEMA = require_failsafe();
  module2.exports.JSON_SCHEMA = require_json();
  module2.exports.CORE_SCHEMA = require_core();
  module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
  module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
  module2.exports.load = loader.load;
  module2.exports.loadAll = loader.loadAll;
  module2.exports.safeLoad = loader.safeLoad;
  module2.exports.safeLoadAll = loader.safeLoadAll;
  module2.exports.dump = dumper.dump;
  module2.exports.safeDump = dumper.safeDump;
  module2.exports.YAMLException = require_exception();
  module2.exports.MINIMAL_SCHEMA = require_failsafe();
  module2.exports.SAFE_SCHEMA = require_default_safe();
  module2.exports.DEFAULT_SCHEMA = require_default_full();
  module2.exports.scan = deprecated("scan");
  module2.exports.parse = deprecated("parse");
  module2.exports.compose = deprecated("compose");
  module2.exports.addConstructor = deprecated("addConstructor");
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS((exports2, module2) => {
  "use strict";
  var yaml = require_js_yaml();
  module2.exports = yaml;
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS((exports2, module2) => {
  module2.exports = {Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C"};
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_entities();
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS((exports2, module2) => {
  module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS((exports2, module2) => {
  "use strict";
  var encodeCache = {};
  function getEncodeCache(exclude) {
    var i, ch, cache = encodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = encodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      if (/^[0-9a-z]$/i.test(ch)) {
        cache.push(ch);
      } else {
        cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
      }
    }
    for (i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }
    return cache;
  }
  function encode(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache, result = "";
    if (typeof exclude !== "string") {
      keepEscaped = exclude;
      exclude = encode.defaultChars;
    }
    if (typeof keepEscaped === "undefined") {
      keepEscaped = true;
    }
    cache = getEncodeCache(exclude);
    for (i = 0, l = string.length; i < l; i++) {
      code = string.charCodeAt(i);
      if (keepEscaped && code === 37 && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
          result += string.slice(i, i + 3);
          i += 2;
          continue;
        }
      }
      if (code < 128) {
        result += cache[code];
        continue;
      }
      if (code >= 55296 && code <= 57343) {
        if (code >= 55296 && code <= 56319 && i + 1 < l) {
          nextCode = string.charCodeAt(i + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            result += encodeURIComponent(string[i] + string[i + 1]);
            i++;
            continue;
          }
        }
        result += "%EF%BF%BD";
        continue;
      }
      result += encodeURIComponent(string[i]);
    }
    return result;
  }
  encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode.componentChars = "-_.!~*'()";
  module2.exports = encode;
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS((exports2, module2) => {
  "use strict";
  var decodeCache = {};
  function getDecodeCache(exclude) {
    var i, ch, cache = decodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = decodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      cache.push(ch);
    }
    for (i = 0; i < exclude.length; i++) {
      ch = exclude.charCodeAt(i);
      cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
    }
    return cache;
  }
  function decode(string, exclude) {
    var cache;
    if (typeof exclude !== "string") {
      exclude = decode.defaultChars;
    }
    cache = getDecodeCache(exclude);
    return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
      var i, l, b1, b2, b3, b4, chr, result = "";
      for (i = 0, l = seq.length; i < l; i += 3) {
        b1 = parseInt(seq.slice(i + 1, i + 3), 16);
        if (b1 < 128) {
          result += cache[b1];
          continue;
        }
        if ((b1 & 224) === 192 && i + 3 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          if ((b2 & 192) === 128) {
            chr = b1 << 6 & 1984 | b2 & 63;
            if (chr < 128) {
              result += "\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 3;
            continue;
          }
        }
        if ((b1 & 240) === 224 && i + 6 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128) {
            chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
              result += "\uFFFD\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 6;
            continue;
          }
        }
        if ((b1 & 248) === 240 && i + 9 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          b4 = parseInt(seq.slice(i + 10, i + 12), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
            chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
            if (chr < 65536 || chr > 1114111) {
              result += "\uFFFD\uFFFD\uFFFD\uFFFD";
            } else {
              chr -= 65536;
              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
            }
            i += 9;
            continue;
          }
        }
        result += "\uFFFD";
      }
      return result;
    });
  }
  decode.defaultChars = ";/?:@&=+$,#";
  decode.componentChars = "";
  module2.exports = decode;
});

// node_modules/mdurl/format.js
var require_format = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function format(url) {
    var result = "";
    result += url.protocol || "";
    result += url.slashes ? "//" : "";
    result += url.auth ? url.auth + "@" : "";
    if (url.hostname && url.hostname.indexOf(":") !== -1) {
      result += "[" + url.hostname + "]";
    } else {
      result += url.hostname || "";
    }
    result += url.port ? ":" + url.port : "";
    result += url.pathname || "";
    result += url.search || "";
    result += url.hash || "";
    return result;
  };
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var hostlessProtocol = {
    javascript: true,
    "javascript:": true
  };
  var slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) {
      return url;
    }
    var u = new Url();
    u.parse(url, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, slashesDenoteHost) {
    var i, l, lowerProto, hec, slashes, rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      if (rest[hostEnd - 1] === ":") {
        hostEnd--;
      }
      var host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost(host);
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      }
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "";
    }
    return this;
  };
  Url.prototype.parseHost = function(host) {
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  module2.exports = urlParse;
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.encode = require_encode();
  module2.exports.decode = require_decode();
  module2.exports.format = require_format();
  module2.exports.parse = require_parse();
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS((exports2, module2) => {
  module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS((exports2, module2) => {
  module2.exports = /[\0-\x1F\x7F-\x9F]/;
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS((exports2, module2) => {
  module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS((exports2, module2) => {
  module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS((exports2) => {
  "use strict";
  exports2.Any = require_regex2();
  exports2.Cc = require_regex3();
  exports2.Cf = require_regex4();
  exports2.P = require_regex();
  exports2.Z = require_regex5();
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString(obj) {
    return _class(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode(c) {
    if (c >= 55296 && c <= 57343) {
      return false;
    }
    if (c >= 64976 && c <= 65007) {
      return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
      return false;
    }
    if (c >= 0 && c <= 8) {
      return false;
    }
    if (c === 11) {
      return false;
    }
    if (c >= 14 && c <= 31) {
      return false;
    }
    if (c >= 127 && c <= 159) {
      return false;
    }
    if (c > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint(c) {
    if (c > 65535) {
      c -= 65536;
      var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities = require_entities2();
  function replaceEntityPattern(match, name) {
    var code = 0;
    if (has(entities, name)) {
      return entities[name];
    }
    if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
      code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
      if (isValidEntityCode(code)) {
        return fromCodePoint(code);
      }
    }
    return match;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match, entity);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  function escapeHtml(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace(code) {
    switch (code) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace(code) {
    if (code >= 8192 && code <= 8202) {
      return true;
    }
    switch (code) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var UNICODE_PUNCT_RE = require_regex();
  function isPunctChar(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }
  function isMdAsciiPunct(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(/ẞ/g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  exports2.lib = {};
  exports2.lib.mdurl = require_mdurl();
  exports2.lib.ucmicro = require_uc();
  exports2.assign = assign;
  exports2.isString = isString;
  exports2.has = has;
  exports2.unescapeMd = unescapeMd;
  exports2.unescapeAll = unescapeAll;
  exports2.isValidEntityCode = isValidEntityCode;
  exports2.fromCodePoint = fromCodePoint;
  exports2.escapeHtml = escapeHtml;
  exports2.arrayReplaceAt = arrayReplaceAt;
  exports2.isSpace = isSpace;
  exports2.isWhiteSpace = isWhiteSpace;
  exports2.isMdAsciiPunct = isMdAsciiPunct;
  exports2.isPunctChar = isPunctChar;
  exports2.escapeRE = escapeRE;
  exports2.normalizeReference = normalizeReference;
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function parseLinkLabel(state, start, disableNested) {
    var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
    state.pos = start + 1;
    level = 1;
    while (state.pos < max) {
      marker = state.src.charCodeAt(state.pos);
      if (marker === 93) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }
      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker === 91) {
        if (prevPos === state.pos - 1) {
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }
    if (found) {
      labelEnd = state.pos;
    }
    state.pos = oldPos;
    return labelEnd;
  };
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS((exports2, module2) => {
  "use strict";
  var unescapeAll = require_utils().unescapeAll;
  module2.exports = function parseLinkDestination(str, pos, max) {
    var code, level, lines = 0, start = pos, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 10) {
          return result;
        }
        if (code === 60) {
          return result;
        }
        if (code === 62) {
          result.pos = pos + 1;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code === 92 && pos + 1 < max) {
          pos += 2;
          continue;
        }
        pos++;
      }
      return result;
    }
    level = 0;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 32) {
        break;
      }
      if (code < 32 || code === 127) {
        break;
      }
      if (code === 92 && pos + 1 < max) {
        if (str.charCodeAt(pos + 1) === 32) {
          break;
        }
        pos += 2;
        continue;
      }
      if (code === 40) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll(str.slice(start, pos));
    result.lines = lines;
    result.pos = pos;
    result.ok = true;
    return result;
  };
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS((exports2, module2) => {
  "use strict";
  var unescapeAll = require_utils().unescapeAll;
  module2.exports = function parseLinkTitle(str, pos, max) {
    var code, marker, lines = 0, start = pos, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (pos >= max) {
      return result;
    }
    marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return result;
    }
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === marker) {
        result.pos = pos + 1;
        result.lines = lines;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      } else if (code === 40 && marker === 41) {
        return result;
      } else if (code === 10) {
        lines++;
      } else if (code === 92 && pos + 1 < max) {
        pos++;
        if (str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
      pos++;
    }
    return result;
  };
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS((exports2) => {
  "use strict";
  exports2.parseLinkLabel = require_parse_link_label();
  exports2.parseLinkDestination = require_parse_link_destination();
  exports2.parseLinkTitle = require_parse_link_title();
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS((exports2, module2) => {
  "use strict";
  var assign = require_utils().assign;
  var unescapeAll = require_utils().unescapeAll;
  var escapeHtml = require_utils().escapeHtml;
  var default_rules = {};
  default_rules.code_inline = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
  };
  default_rules.code_block = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
  };
  default_rules.fence = function(tokens, idx, options, env, slf) {
    var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
    if (info) {
      arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join("");
    }
    if (options.highlight) {
      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }
    if (highlighted.indexOf("<pre") === 0) {
      return highlighted + "\n";
    }
    if (info) {
      i = token.attrIndex("class");
      tmpAttrs = token.attrs ? token.attrs.slice() : [];
      if (i < 0) {
        tmpAttrs.push(["class", options.langPrefix + langName]);
      } else {
        tmpAttrs[i] = tmpAttrs[i].slice();
        tmpAttrs[i][1] += " " + options.langPrefix + langName;
      }
      tmpToken = {
        attrs: tmpAttrs
      };
      return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
    }
    return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
  };
  default_rules.image = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
    return slf.renderToken(tokens, idx, options);
  };
  default_rules.hardbreak = function(tokens, idx, options) {
    return options.xhtmlOut ? "<br />\n" : "<br>\n";
  };
  default_rules.softbreak = function(tokens, idx, options) {
    return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  };
  default_rules.text = function(tokens, idx) {
    return escapeHtml(tokens[idx].content);
  };
  default_rules.html_block = function(tokens, idx) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function(tokens, idx) {
    return tokens[idx].content;
  };
  function Renderer() {
    this.rules = assign({}, default_rules);
  }
  Renderer.prototype.renderAttrs = function renderAttrs(token) {
    var i, l, result;
    if (!token.attrs) {
      return "";
    }
    result = "";
    for (i = 0, l = token.attrs.length; i < l; i++) {
      result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
    }
    return result;
  };
  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
    var nextToken, result = "", needLf = false, token = tokens[idx];
    if (token.hidden) {
      return "";
    }
    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += "\n";
    }
    result += (token.nesting === -1 ? "</" : "<") + token.tag;
    result += this.renderAttrs(token);
    if (token.nesting === 0 && options.xhtmlOut) {
      result += " /";
    }
    if (token.block) {
      needLf = true;
      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          nextToken = tokens[idx + 1];
          if (nextToken.type === "inline" || nextToken.hidden) {
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            needLf = false;
          }
        }
      }
    }
    result += needLf ? ">\n" : ">";
    return result;
  };
  Renderer.prototype.renderInline = function(tokens, options, env) {
    var type, result = "", rules = this.rules;
    for (var i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (typeof rules[type] !== "undefined") {
        result += rules[type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options);
      }
    }
    return result;
  };
  Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
    var result = "";
    for (var i = 0, len = tokens.length; i < len; i++) {
      if (tokens[i].type === "text") {
        result += tokens[i].content;
      } else if (tokens[i].type === "image") {
        result += this.renderInlineAsText(tokens[i].children, options, env);
      }
    }
    return result;
  };
  Renderer.prototype.render = function(tokens, options, env) {
    var i, len, type, result = "", rules = this.rules;
    for (i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (type === "inline") {
        result += this.renderInline(tokens[i].children, options, env);
      } else if (typeof rules[type] !== "undefined") {
        result += rules[tokens[i].type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options, env);
      }
    }
    return result;
  };
  module2.exports = Renderer;
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS((exports2, module2) => {
  "use strict";
  function Ruler() {
    this.__rules__ = [];
    this.__cache__ = null;
  }
  Ruler.prototype.__find__ = function(name) {
    for (var i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name) {
        return i;
      }
    }
    return -1;
  };
  Ruler.prototype.__compile__ = function() {
    var self = this;
    var chains = [""];
    self.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      rule.alt.forEach(function(altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });
    self.__cache__ = {};
    chains.forEach(function(chain) {
      self.__cache__[chain] = [];
      self.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }
        self.__cache__[chain].push(rule.fn);
      });
    });
  };
  Ruler.prototype.at = function(name, fn, options) {
    var index = this.__find__(name);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + name);
    }
    this.__rules__[index].fn = fn;
    this.__rules__[index].alt = opt.alt || [];
    this.__cache__ = null;
  };
  Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
    var index = this.__find__(beforeName);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(index, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.after = function(afterName, ruleName, fn, options) {
    var index = this.__find__(afterName);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(index + 1, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.push = function(ruleName, fn, options) {
    var opt = options || {};
    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.enable = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }
    var result = [];
    list.forEach(function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = true;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }
    this.__rules__.forEach(function(rule) {
      rule.enabled = false;
    });
    this.enable(list, ignoreInvalid);
  };
  Ruler.prototype.disable = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }
    var result = [];
    list.forEach(function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = false;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }
    return this.__cache__[chainName] || [];
  };
  module2.exports = Ruler;
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS((exports2, module2) => {
  "use strict";
  var NEWLINES_RE = /\r\n?|\n/g;
  var NULL_RE = /\0/g;
  module2.exports = function normalize(state) {
    var str;
    str = state.src.replace(NEWLINES_RE, "\n");
    str = str.replace(NULL_RE, "\uFFFD");
    state.src = str;
  };
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function block(state) {
    var token;
    if (state.inlineMode) {
      token = new state.Token("inline", "", 0);
      token.content = state.src;
      token.map = [0, 1];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  };
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function inline(state) {
    var tokens = state.tokens, tok, i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      tok = tokens[i];
      if (tok.type === "inline") {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS((exports2, module2) => {
  "use strict";
  var arrayReplaceAt = require_utils().arrayReplaceAt;
  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }
  module2.exports = function linkify(state) {
    var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
    if (!state.md.options.linkify) {
      return;
    }
    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
        continue;
      }
      tokens = blockTokens[j].children;
      htmlLinkLevel = 0;
      for (i = tokens.length - 1; i >= 0; i--) {
        currentToken = tokens[i];
        if (currentToken.type === "link_close") {
          i--;
          while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
            i--;
          }
          continue;
        }
        if (currentToken.type === "html_inline") {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) {
          continue;
        }
        if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
          text = currentToken.content;
          links = state.md.linkify.match(text);
          nodes = [];
          level = currentToken.level;
          lastPos = 0;
          for (ln = 0; ln < links.length; ln++) {
            url = links[ln].url;
            fullUrl = state.md.normalizeLink(url);
            if (!state.md.validateLink(fullUrl)) {
              continue;
            }
            urlText = links[ln].text;
            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }
            pos = links[ln].index;
            if (pos > lastPos) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos, pos);
              token.level = level;
              nodes.push(token);
            }
            token = new state.Token("link_open", "a", 1);
            token.attrs = [["href", fullUrl]];
            token.level = level++;
            token.markup = "linkify";
            token.info = "auto";
            nodes.push(token);
            token = new state.Token("text", "", 0);
            token.content = urlText;
            token.level = level;
            nodes.push(token);
            token = new state.Token("link_close", "a", -1);
            token.level = --level;
            token.markup = "linkify";
            token.info = "auto";
            nodes.push(token);
            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text.length) {
            token = new state.Token("text", "", 0);
            token.content = text.slice(lastPos);
            token.level = level;
            nodes.push(token);
          }
          blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS((exports2, module2) => {
  "use strict";
  var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
  var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
  var SCOPED_ABBR = {
    c: "\xA9",
    r: "\xAE",
    p: "\xA7",
    tm: "\u2122"
  };
  function replaceFn(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  }
  function replace_scoped(inlineTokens) {
    var i, token, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace_rare(inlineTokens) {
    var i, token, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
        }
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  module2.exports = function replace(state) {
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline") {
        continue;
      }
      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }
      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS((exports2, module2) => {
  "use strict";
  var isWhiteSpace = require_utils().isWhiteSpace;
  var isPunctChar = require_utils().isPunctChar;
  var isMdAsciiPunct = require_utils().isMdAsciiPunct;
  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE = "\u2019";
  function replaceAt(str, index, ch) {
    return str.substr(0, index) + ch + str.substr(index + 1);
  }
  function process_inlines(tokens, state) {
    var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
    stack = [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      thisLevel = tokens[i].level;
      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) {
          break;
        }
      }
      stack.length = j + 1;
      if (token.type !== "text") {
        continue;
      }
      text = token.content;
      pos = 0;
      max = text.length;
      OUTER:
        while (pos < max) {
          QUOTE_RE.lastIndex = pos;
          t = QUOTE_RE.exec(text);
          if (!t) {
            break;
          }
          canOpen = canClose = true;
          pos = t.index + 1;
          isSingle = t[0] === "'";
          lastChar = 32;
          if (t.index - 1 >= 0) {
            lastChar = text.charCodeAt(t.index - 1);
          } else {
            for (j = i - 1; j >= 0; j--) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                break;
              if (!tokens[j].content)
                continue;
              lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
              break;
            }
          }
          nextChar = 32;
          if (pos < max) {
            nextChar = text.charCodeAt(pos);
          } else {
            for (j = i + 1; j < tokens.length; j++) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                break;
              if (!tokens[j].content)
                continue;
              nextChar = tokens[j].content.charCodeAt(0);
              break;
            }
          }
          isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
          isLastWhiteSpace = isWhiteSpace(lastChar);
          isNextWhiteSpace = isWhiteSpace(nextChar);
          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }
          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }
          if (nextChar === 34 && t[0] === '"') {
            if (lastChar >= 48 && lastChar <= 57) {
              canClose = canOpen = false;
            }
          }
          if (canOpen && canClose) {
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }
          if (!canOpen && !canClose) {
            if (isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
            continue;
          }
          if (canClose) {
            for (j = stack.length - 1; j >= 0; j--) {
              item = stack[j];
              if (stack[j].level < thisLevel) {
                break;
              }
              if (item.single === isSingle && stack[j].level === thisLevel) {
                item = stack[j];
                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }
                token.content = replaceAt(token.content, t.index, closeQuote);
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                pos += closeQuote.length - 1;
                if (item.token === i) {
                  pos += openQuote.length - 1;
                }
                text = token.content;
                max = text.length;
                stack.length = j;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i,
              pos: t.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
        }
    }
  }
  module2.exports = function smartquotes(state) {
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }
      process_inlines(state.tokens[blkIdx].children, state);
    }
  };
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS((exports2, module2) => {
  "use strict";
  function Token(type, tag, nesting) {
    this.type = type;
    this.tag = tag;
    this.attrs = null;
    this.map = null;
    this.nesting = nesting;
    this.level = 0;
    this.children = null;
    this.content = "";
    this.markup = "";
    this.info = "";
    this.meta = null;
    this.block = false;
    this.hidden = false;
  }
  Token.prototype.attrIndex = function attrIndex(name) {
    var attrs, i, len;
    if (!this.attrs) {
      return -1;
    }
    attrs = this.attrs;
    for (i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name) {
        return i;
      }
    }
    return -1;
  };
  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [attrData];
    }
  };
  Token.prototype.attrSet = function attrSet(name, value) {
    var idx = this.attrIndex(name), attrData = [name, value];
    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  Token.prototype.attrGet = function attrGet(name) {
    var idx = this.attrIndex(name), value = null;
    if (idx >= 0) {
      value = this.attrs[idx][1];
    }
    return value;
  };
  Token.prototype.attrJoin = function attrJoin(name, value) {
    var idx = this.attrIndex(name);
    if (idx < 0) {
      this.attrPush([name, value]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
    }
  };
  module2.exports = Token;
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS((exports2, module2) => {
  "use strict";
  var Token = require_token();
  function StateCore(src, md, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md;
  }
  StateCore.prototype.Token = Token;
  module2.exports = StateCore;
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS((exports2, module2) => {
  "use strict";
  var Ruler = require_ruler();
  var _rules = [
    ["normalize", require_normalize()],
    ["block", require_block()],
    ["inline", require_inline()],
    ["linkify", require_linkify()],
    ["replacements", require_replacements()],
    ["smartquotes", require_smartquotes()]
  ];
  function Core() {
    this.ruler = new Ruler();
    for (var i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
  }
  Core.prototype.process = function(state) {
    var i, l, rules;
    rules = this.ruler.getRules("");
    for (i = 0, l = rules.length; i < l; i++) {
      rules[i](state);
    }
  };
  Core.prototype.State = require_state_core();
  module2.exports = Core;
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  function getLine(state, line) {
    var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
    return state.src.substr(pos, max - pos);
  }
  function escapedSplit(str) {
    var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
    ch = str.charCodeAt(pos);
    while (pos < max) {
      if (ch === 124) {
        if (!isEscaped) {
          result.push(current + str.substring(lastPos, pos));
          current = "";
          lastPos = pos + 1;
        } else {
          current += str.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }
      isEscaped = ch === 92;
      pos++;
      ch = str.charCodeAt(pos);
    }
    result.push(current + str.substring(lastPos));
    return result;
  }
  module2.exports = function table(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules;
    if (startLine + 2 > endLine) {
      return false;
    }
    nextLine = startLine + 1;
    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch !== 124 && ch !== 45 && ch !== 58) {
      return false;
    }
    while (pos < state.eMarks[nextLine]) {
      ch = state.src.charCodeAt(pos);
      if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
        return false;
      }
      pos++;
    }
    lineText = getLine(state, startLine + 1);
    columns = lineText.split("|");
    aligns = [];
    for (i = 0; i < columns.length; i++) {
      t = columns[i].trim();
      if (!t) {
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }
      if (!/^:?-+:?$/.test(t)) {
        return false;
      }
      if (t.charCodeAt(t.length - 1) === 58) {
        aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
      } else if (t.charCodeAt(0) === 58) {
        aligns.push("left");
      } else {
        aligns.push("");
      }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
      return false;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) {
      return false;
    }
    if (silent) {
      return true;
    }
    oldParentType = state.parentType;
    state.parentType = "table";
    terminatorRules = state.md.block.ruler.getRules("blockquote");
    token = state.push("table_open", "table", 1);
    token.map = tableLines = [startLine, 0];
    token = state.push("thead_open", "thead", 1);
    token.map = [startLine, startLine + 1];
    token = state.push("tr_open", "tr", 1);
    token.map = [startLine, startLine + 1];
    for (i = 0; i < columns.length; i++) {
      token = state.push("th_open", "th", 1);
      if (aligns[i]) {
        token.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token = state.push("inline", "", 0);
      token.content = columns[i].trim();
      token.children = [];
      token = state.push("th_close", "th", -1);
    }
    token = state.push("tr_close", "tr", -1);
    token = state.push("thead_close", "thead", -1);
    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      if (nextLine === startLine + 2) {
        token = state.push("tbody_open", "tbody", 1);
        token.map = tbodyLines = [startLine + 2, 0];
      }
      token = state.push("tr_open", "tr", 1);
      token.map = [nextLine, nextLine + 1];
      for (i = 0; i < columnCount; i++) {
        token = state.push("td_open", "td", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i] ? columns[i].trim() : "";
        token.children = [];
        token = state.push("td_close", "td", -1);
      }
      token = state.push("tr_close", "tr", -1);
    }
    if (tbodyLines) {
      token = state.push("tbody_close", "tbody", -1);
      tbodyLines[1] = nextLine;
    }
    token = state.push("table_close", "table", -1);
    tableLines[1] = nextLine;
    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function code(state, startLine, endLine) {
    var nextLine, last, token;
    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }
    last = nextLine = startLine + 1;
    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }
      break;
    }
    state.line = last;
    token = state.push("code_block", "code", 0);
    token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
    token.map = [startLine, state.line];
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function fence(state, startLine, endLine, silent) {
    var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (pos + 3 > max) {
      return false;
    }
    marker = state.src.charCodeAt(pos);
    if (marker !== 126 && marker !== 96) {
      return false;
    }
    mem = pos;
    pos = state.skipChars(pos, marker);
    len = pos - mem;
    if (len < 3) {
      return false;
    }
    markup = state.src.slice(mem, pos);
    params = state.src.slice(pos, max);
    if (marker === 96) {
      if (params.indexOf(String.fromCharCode(marker)) >= 0) {
        return false;
      }
    }
    if (silent) {
      return true;
    }
    nextLine = startLine;
    for (; ; ) {
      nextLine++;
      if (nextLine >= endLine) {
        break;
      }
      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.src.charCodeAt(pos) !== marker) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        continue;
      }
      pos = state.skipChars(pos, marker);
      if (pos - mem < len) {
        continue;
      }
      pos = state.skipSpaces(pos);
      if (pos < max) {
        continue;
      }
      haveEndMarker = true;
      break;
    }
    len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    token = state.push("fence", "code", 0);
    token.info = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup = markup;
    token.map = [startLine, state.line];
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  module2.exports = function blockquote(state, startLine, endLine, silent) {
    var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos++) !== 62) {
      return false;
    }
    if (silent) {
      return true;
    }
    initial = offset = state.sCount[startLine] + 1;
    if (state.src.charCodeAt(pos) === 32) {
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 9) {
      spaceAfterMarker = true;
      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        adjustTab = true;
      }
    } else {
      spaceAfterMarker = false;
    }
    oldBMarks = [state.bMarks[startLine]];
    state.bMarks[startLine] = pos;
    while (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (isSpace(ch)) {
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }
      pos++;
    }
    oldBSCount = [state.bsCount[startLine]];
    state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
    lastLineEmpty = pos >= max;
    oldSCount = [state.sCount[startLine]];
    state.sCount[startLine] = offset - initial;
    oldTShift = [state.tShift[startLine]];
    state.tShift[startLine] = pos - state.bMarks[startLine];
    terminatorRules = state.md.block.ruler.getRules("blockquote");
    oldParentType = state.parentType;
    state.parentType = "blockquote";
    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
      isOutdented = state.sCount[nextLine] < state.blkIndent;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos >= max) {
        break;
      }
      if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
        initial = offset = state.sCount[nextLine] + 1;
        if (state.src.charCodeAt(pos) === 32) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9) {
          spaceAfterMarker = true;
          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (isSpace(ch)) {
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        lastLineEmpty = pos >= max;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }
      if (lastLineEmpty) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        state.lineMax = nextLine;
        if (state.blkIndent !== 0) {
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }
        break;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = -1;
    }
    oldIndent = state.blkIndent;
    state.blkIndent = 0;
    token = state.push("blockquote_open", "blockquote", 1);
    token.markup = ">";
    token.map = lines = [startLine, 0];
    state.md.block.tokenize(state, startLine, nextLine);
    token = state.push("blockquote_close", "blockquote", -1);
    token.markup = ">";
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;
    for (i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }
    state.blkIndent = oldIndent;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  module2.exports = function hr(state, startLine, endLine, silent) {
    var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 95) {
      return false;
    }
    cnt = 1;
    while (pos < max) {
      ch = state.src.charCodeAt(pos++);
      if (ch !== marker && !isSpace(ch)) {
        return false;
      }
      if (ch === marker) {
        cnt++;
      }
    }
    if (cnt < 3) {
      return false;
    }
    if (silent) {
      return true;
    }
    state.line = startLine + 1;
    token = state.push("hr", "hr", 0);
    token.map = [startLine, state.line];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  function skipBulletListMarker(state, startLine) {
    var marker, pos, max, ch;
    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];
    marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 43) {
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function skipOrderedListMarker(state, startLine) {
    var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
    if (pos + 1 >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch < 48 || ch > 57) {
      return -1;
    }
    for (; ; ) {
      if (pos >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch >= 48 && ch <= 57) {
        if (pos - start >= 10) {
          return -1;
        }
        continue;
      }
      if (ch === 41 || ch === 46) {
        break;
      }
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function markTightParagraphs(state, idx) {
    var i, l, level = state.level + 2;
    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }
  module2.exports = function list(state, startLine, endLine, silent) {
    var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
      return false;
    }
    if (silent && state.parentType === "paragraph") {
      if (state.tShift[startLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }
    if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[startLine] + state.tShift[startLine];
      markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
      if (isTerminatingParagraph && markerValue !== 1)
        return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    }
    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
        return false;
    }
    markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    if (silent) {
      return true;
    }
    listTokIdx = state.tokens.length;
    if (isOrdered) {
      token = state.push("ordered_list_open", "ol", 1);
      if (markerValue !== 1) {
        token.attrs = [["start", markerValue]];
      }
    } else {
      token = state.push("bullet_list_open", "ul", 1);
    }
    token.map = listLines = [startLine, 0];
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine;
    prevEmptyEnd = false;
    terminatorRules = state.md.block.ruler.getRules("list");
    oldParentType = state.parentType;
    state.parentType = "list";
    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];
      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 32) {
          offset++;
        } else {
          break;
        }
        pos++;
      }
      contentStart = pos;
      if (contentStart >= max) {
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }
      if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      }
      indent = initial + indentAfterMarker;
      token = state.push("list_item_open", "li", 1);
      token.markup = String.fromCharCode(markerCharCode);
      token.map = itemLines = [startLine, 0];
      oldTight = state.tight;
      oldTShift = state.tShift[startLine];
      oldSCount = state.sCount[startLine];
      oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[startLine] = contentStart - state.bMarks[startLine];
      state.sCount[startLine] = offset;
      if (contentStart >= max && state.isEmpty(startLine + 1)) {
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, startLine, endLine, true);
      }
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[startLine] = oldTShift;
      state.sCount[startLine] = oldSCount;
      state.tight = oldTight;
      token = state.push("list_item_close", "li", -1);
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine = state.line;
      itemLines[1] = nextLine;
      contentStart = state.bMarks[startLine];
      if (nextLine >= endLine) {
        break;
      }
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      }
      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    }
    if (isOrdered) {
      token = state.push("ordered_list_close", "ol", -1);
    } else {
      token = state.push("bullet_list_close", "ul", -1);
    }
    token.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType;
    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS((exports2, module2) => {
  "use strict";
  var normalizeReference = require_utils().normalizeReference;
  var isSpace = require_utils().isSpace;
  module2.exports = function reference(state, startLine, _endLine, silent) {
    var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 91) {
      return false;
    }
    while (++pos < max) {
      if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 58) {
          return false;
        }
        break;
      }
    }
    endLine = state.lineMax;
    terminatorRules = state.md.block.ruler.getRules("reference");
    oldParentType = state.parentType;
    state.parentType = "reference";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    max = str.length;
    for (pos = 1; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 91) {
        return false;
      } else if (ch === 93) {
        labelEnd = pos;
        break;
      } else if (ch === 10) {
        lines++;
      } else if (ch === 92) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
    }
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
      return false;
    }
    for (pos = labelEnd + 2; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace(ch)) {
      } else {
        break;
      }
    }
    res = state.md.helpers.parseLinkDestination(str, pos, max);
    if (!res.ok) {
      return false;
    }
    href = state.md.normalizeLink(res.str);
    if (!state.md.validateLink(href)) {
      return false;
    }
    pos = res.pos;
    lines += res.lines;
    destEndPos = pos;
    destEndLineNo = lines;
    start = pos;
    for (; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace(ch)) {
      } else {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(str, pos, max);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      lines += res.lines;
    } else {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
    }
    while (pos < max) {
      ch = str.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
      pos++;
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      if (title) {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
        while (pos < max) {
          ch = str.charCodeAt(pos);
          if (!isSpace(ch)) {
            break;
          }
          pos++;
        }
      }
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      return false;
    }
    label = normalizeReference(str.slice(1, labelEnd));
    if (!label) {
      return false;
    }
    if (silent) {
      return true;
    }
    if (typeof state.env.references === "undefined") {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === "undefined") {
      state.env.references[label] = {title, href};
    }
    state.parentType = oldParentType;
    state.line = startLine + lines + 1;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  module2.exports = function heading(state, startLine, endLine, silent) {
    var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    ch = state.src.charCodeAt(pos);
    if (ch !== 35 || pos >= max) {
      return false;
    }
    level = 1;
    ch = state.src.charCodeAt(++pos);
    while (ch === 35 && pos < max && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max && !isSpace(ch)) {
      return false;
    }
    if (silent) {
      return true;
    }
    max = state.skipSpacesBack(max, pos);
    tmp = state.skipCharsBack(max, 35, pos);
    if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }
    state.line = startLine + 1;
    token = state.push("heading_open", "h" + String(level), 1);
    token.markup = "########".slice(0, level);
    token.map = [startLine, state.line];
    token = state.push("inline", "", 0);
    token.content = state.src.slice(pos, max).trim();
    token.map = [startLine, state.line];
    token.children = [];
    token = state.push("heading_close", "h" + String(level), -1);
    token.markup = "########".slice(0, level);
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function lheading(state, startLine, endLine) {
    var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    oldParentType = state.parentType;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] >= state.blkIndent) {
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max) {
          marker = state.src.charCodeAt(pos);
          if (marker === 45 || marker === 61) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);
            if (pos >= max) {
              level = marker === 61 ? 1 : 2;
              break;
            }
          }
        }
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    if (!level) {
      return false;
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    token = state.push("heading_open", "h" + String(level), 1);
    token.markup = String.fromCharCode(marker);
    token.map = [startLine, state.line];
    token = state.push("inline", "", 0);
    token.content = content;
    token.map = [startLine, state.line - 1];
    token.children = [];
    token = state.push("heading_close", "h" + String(level), -1);
    token.markup = String.fromCharCode(marker);
    state.parentType = oldParentType;
    return true;
  };
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "section",
    "source",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS((exports2, module2) => {
  "use strict";
  var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var unquoted = "[^\"'=<>`\\x00-\\x20]+";
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';
  var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
  var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
  var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
  var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
  var processing = "<[?][\\s\\S]*?[?]>";
  var declaration = "<![A-Z]+\\s+[^>]*>";
  var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
  var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
  module2.exports.HTML_TAG_RE = HTML_TAG_RE;
  module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS((exports2, module2) => {
  "use strict";
  var block_names = require_html_blocks();
  var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
  var HTML_SEQUENCES = [
    [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
    [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
  ];
  module2.exports = function html_block(state, startLine, endLine, silent) {
    var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    lineText = state.src.slice(pos, max);
    for (i = 0; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) {
        break;
      }
    }
    if (i === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      return HTML_SEQUENCES[i][2];
    }
    nextLine = startLine + 1;
    if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);
        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    token = state.push("html_block", "", 0);
    token.map = [startLine, nextLine];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function paragraph(state, startLine) {
    var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
    oldParentType = state.parentType;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    token = state.push("paragraph_open", "p", 1);
    token.map = [startLine, state.line];
    token = state.push("inline", "", 0);
    token.content = content;
    token.map = [startLine, state.line];
    token.children = [];
    token = state.push("paragraph_close", "p", -1);
    state.parentType = oldParentType;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS((exports2, module2) => {
  "use strict";
  var Token = require_token();
  var isSpace = require_utils().isSpace;
  function StateBlock(src, md, env, tokens) {
    var ch, s, start, pos, len, indent, offset, indent_found;
    this.src = src;
    this.md = md;
    this.env = env;
    this.tokens = tokens;
    this.bMarks = [];
    this.eMarks = [];
    this.tShift = [];
    this.sCount = [];
    this.bsCount = [];
    this.blkIndent = 0;
    this.line = 0;
    this.lineMax = 0;
    this.tight = false;
    this.ddIndent = -1;
    this.listIndent = -1;
    this.parentType = "root";
    this.level = 0;
    this.result = "";
    s = this.src;
    indent_found = false;
    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
      ch = s.charCodeAt(pos);
      if (!indent_found) {
        if (isSpace(ch)) {
          indent++;
          if (ch === 9) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }
      if (ch === 10 || pos === len - 1) {
        if (ch !== 10) {
          pos++;
        }
        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    }
    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1;
  }
  StateBlock.prototype.push = function(type, tag, nesting) {
    var token = new Token(type, tag, nesting);
    token.block = true;
    if (nesting < 0)
      this.level--;
    token.level = this.level;
    if (nesting > 0)
      this.level++;
    this.tokens.push(token);
    return token;
  };
  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };
  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (var max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };
  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    var ch;
    for (var max = this.src.length; pos < max; pos++) {
      ch = this.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (!isSpace(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipChars = function skipChars(pos, code) {
    for (var max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (code !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
    if (begin >= end) {
      return "";
    }
    queue = new Array(end - begin);
    for (i = 0; line < end; line++, i++) {
      lineIndent = 0;
      lineStart = first = this.bMarks[line];
      if (line + 1 < end || keepLastLF) {
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }
      while (first < last && lineIndent < indent) {
        ch = this.src.charCodeAt(first);
        if (isSpace(ch)) {
          if (ch === 9) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          lineIndent++;
        } else {
          break;
        }
        first++;
      }
      if (lineIndent > indent) {
        queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
      } else {
        queue[i] = this.src.slice(first, last);
      }
    }
    return queue.join("");
  };
  StateBlock.prototype.Token = Token;
  module2.exports = StateBlock;
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS((exports2, module2) => {
  "use strict";
  var Ruler = require_ruler();
  var _rules = [
    ["table", require_table(), ["paragraph", "reference"]],
    ["code", require_code()],
    ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
    ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
    ["list", require_list(), ["paragraph", "reference", "blockquote"]],
    ["reference", require_reference()],
    ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
    ["lheading", require_lheading()],
    ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
    ["paragraph", require_paragraph()]
  ];
  function ParserBlock() {
    this.ruler = new Ruler();
    for (var i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1], {alt: (_rules[i][2] || []).slice()});
    }
  }
  ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) {
        break;
      }
      if (state.sCount[line] < state.blkIndent) {
        break;
      }
      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }
      for (i = 0; i < len; i++) {
        ok = rules[i](state, line, endLine, false);
        if (ok) {
          break;
        }
      }
      state.tight = !hasEmptyLines;
      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }
      line = state.line;
      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  ParserBlock.prototype.parse = function(src, md, env, outTokens) {
    var state;
    if (!src) {
      return;
    }
    state = new this.State(src, md, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };
  ParserBlock.prototype.State = require_state_block();
  module2.exports = ParserBlock;
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS((exports2, module2) => {
  "use strict";
  function isTerminatorChar(ch) {
    switch (ch) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  module2.exports = function text(state, silent) {
    var pos = state.pos;
    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }
    if (pos === state.pos) {
      return false;
    }
    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  module2.exports = function newline(state, silent) {
    var pmax, max, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10) {
      return false;
    }
    pmax = state.pending.length - 1;
    max = state.posMax;
    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
          state.pending = state.pending.replace(/ +$/, "");
          state.push("hardbreak", "br", 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push("softbreak", "br", 0);
        }
      } else {
        state.push("softbreak", "br", 0);
      }
    }
    pos++;
    while (pos < max && isSpace(state.src.charCodeAt(pos))) {
      pos++;
    }
    state.pos = pos;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  var isSpace = require_utils().isSpace;
  var ESCAPED = [];
  for (var i = 0; i < 256; i++) {
    ESCAPED.push(0);
  }
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
  });
  module2.exports = function escape(state, silent) {
    var ch, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 92) {
      return false;
    }
    pos++;
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (ch < 256 && ESCAPED[ch] !== 0) {
        if (!silent) {
          state.pending += state.src[pos];
        }
        state.pos += 2;
        return true;
      }
      if (ch === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (!isSpace(ch)) {
            break;
          }
          pos++;
        }
        state.pos = pos;
        return true;
      }
    }
    if (!silent) {
      state.pending += "\\";
    }
    state.pos++;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function backtick(state, silent) {
    var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
    if (ch !== 96) {
      return false;
    }
    start = pos;
    pos++;
    max = state.posMax;
    while (pos < max && state.src.charCodeAt(pos) === 96) {
      pos++;
    }
    marker = state.src.slice(start, pos);
    openerLength = marker.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    matchStart = matchEnd = pos;
    while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
        matchEnd++;
      }
      closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        if (!silent) {
          token = state.push("code_inline", "code", 0);
          token.markup = marker;
          token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
        }
        state.pos = matchEnd;
        return true;
      }
      state.backticks[closerLength] = matchStart;
    }
    state.backticksScanned = true;
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.tokenize = function strikethrough(state, silent) {
    var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 126) {
      return false;
    }
    scanned = state.scanDelims(state.pos, true);
    len = scanned.length;
    ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (i = 0; i < len; i += 2) {
      token = state.push("text", "", 0);
      token.content = ch + ch;
      state.delimiters.push({
        marker,
        length: 0,
        jump: i / 2,
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess(state, delimiters) {
    var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
    for (i = 0; i < max; i++) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 126) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "s_open";
      token.tag = "s";
      token.nesting = 1;
      token.markup = "~~";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "s_close";
      token.tag = "s";
      token.nesting = -1;
      token.markup = "~~";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      i = loneMarkers.pop();
      j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "s_close") {
        j++;
      }
      j--;
      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  module2.exports.postProcess = function strikethrough(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.tokenize = function emphasis(state, silent) {
    var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 95 && marker !== 42) {
      return false;
    }
    scanned = state.scanDelims(state.pos, marker === 42);
    for (i = 0; i < scanned.length; i++) {
      token = state.push("text", "", 0);
      token.content = String.fromCharCode(marker);
      state.delimiters.push({
        marker,
        length: scanned.length,
        jump: i,
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess(state, delimiters) {
    var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
    for (i = max - 1; i >= 0; i--) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 95 && startDelim.marker !== 42) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;
      ch = String.fromCharCode(startDelim.marker);
      token = state.tokens[startDelim.token];
      token.type = isStrong ? "strong_open" : "em_open";
      token.tag = isStrong ? "strong" : "em";
      token.nesting = 1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = isStrong ? "strong_close" : "em_close";
      token.tag = isStrong ? "strong" : "em";
      token.nesting = -1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = "";
      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = "";
        state.tokens[delimiters[startDelim.end + 1].token].content = "";
        i--;
      }
    }
  }
  module2.exports.postProcess = function emphasis(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS((exports2, module2) => {
  "use strict";
  var normalizeReference = require_utils().normalizeReference;
  var isSpace = require_utils().isSpace;
  module2.exports = function link(state, silent) {
    var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    labelStart = state.pos + 1;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      parseReference = false;
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        }
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      token = state.push("link_open", "a", 1);
      token.attrs = attrs = [["href", href]];
      if (title) {
        attrs.push(["title", title]);
      }
      state.md.inline.tokenize(state);
      token = state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS((exports2, module2) => {
  "use strict";
  var normalizeReference = require_utils().normalizeReference;
  var isSpace = require_utils().isSpace;
  module2.exports = function image(state, silent) {
    var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    labelStart = state.pos + 2;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      state.md.inline.parse(content, state.md, state.env, tokens = []);
      token = state.push("image", "img", 0);
      token.attrs = attrs = [["src", href], ["alt", ""]];
      token.children = tokens;
      token.content = content;
      if (title) {
        attrs.push(["title", title]);
      }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS((exports2, module2) => {
  "use strict";
  var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  module2.exports = function autolink(state, silent) {
    var url, fullUrl, token, ch, start, max, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    start = state.pos;
    max = state.posMax;
    for (; ; ) {
      if (++pos >= max)
        return false;
      ch = state.src.charCodeAt(pos);
      if (ch === 60)
        return false;
      if (ch === 62)
        break;
    }
    url = state.src.slice(start + 1, pos);
    if (AUTOLINK_RE.test(url)) {
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "autolink";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "autolink";
        token.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    if (EMAIL_RE.test(url)) {
      fullUrl = state.md.normalizeLink("mailto:" + url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "autolink";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "autolink";
        token.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    return false;
  };
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS((exports2, module2) => {
  "use strict";
  var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
  function isLetter(ch) {
    var lc = ch | 32;
    return lc >= 97 && lc <= 122;
  }
  module2.exports = function html_inline(state, silent) {
    var ch, match, max, token, pos = state.pos;
    if (!state.md.options.html) {
      return false;
    }
    max = state.posMax;
    if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
      return false;
    }
    ch = state.src.charCodeAt(pos + 1);
    if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
      return false;
    }
    match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) {
      return false;
    }
    if (!silent) {
      token = state.push("html_inline", "", 0);
      token.content = state.src.slice(pos, pos + match[0].length);
    }
    state.pos += match[0].length;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS((exports2, module2) => {
  "use strict";
  var entities = require_entities2();
  var has = require_utils().has;
  var isValidEntityCode = require_utils().isValidEntityCode;
  var fromCodePoint = require_utils().fromCodePoint;
  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
  module2.exports = function entity(state, silent) {
    var ch, code, match, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 38) {
      return false;
    }
    if (pos + 1 < max) {
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              state.pending += entities[match[1]];
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
    }
    if (!silent) {
      state.pending += "&";
    }
    state.pos++;
    return true;
  };
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS((exports2, module2) => {
  "use strict";
  function processDelimiters(state, delimiters) {
    var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
    for (closerIdx = 0; closerIdx < max; closerIdx++) {
      closer = delimiters[closerIdx];
      closer.length = closer.length || 0;
      if (!closer.close)
        continue;
      if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [-1, -1, -1];
      }
      minOpenerIdx = openersBottom[closer.marker][closer.length % 3];
      openerIdx = closerIdx - closer.jump - 1;
      if (openerIdx < -1)
        openerIdx = -1;
      newMinOpenerIdx = openerIdx;
      for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {
        opener = delimiters[openerIdx];
        if (opener.marker !== closer.marker)
          continue;
        if (opener.open && opener.end < 0) {
          isOddMatch = false;
          if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }
          if (!isOddMatch) {
            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? delimiters[openerIdx - 1].jump + 1 : 0;
            closer.jump = closerIdx - openerIdx + lastJump;
            closer.open = false;
            opener.end = closerIdx;
            opener.jump = lastJump;
            opener.close = false;
            newMinOpenerIdx = -1;
            break;
          }
        }
      }
      if (newMinOpenerIdx !== -1) {
        openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;
      }
    }
  }
  module2.exports = function link_pairs(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    processDelimiters(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(state, tokens_meta[curr].delimiters);
      }
    }
  };
});

// node_modules/markdown-it/lib/rules_inline/text_collapse.js
var require_text_collapse = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function text_collapse(state) {
    var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].nesting < 0)
        level--;
      tokens[curr].level = level;
      if (tokens[curr].nesting > 0)
        level++;
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  };
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS((exports2, module2) => {
  "use strict";
  var Token = require_token();
  var isWhiteSpace = require_utils().isWhiteSpace;
  var isPunctChar = require_utils().isPunctChar;
  var isMdAsciiPunct = require_utils().isMdAsciiPunct;
  function StateInline(src, md, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    this.cache = {};
    this.delimiters = [];
    this._prev_delimiters = [];
    this.backticks = {};
    this.backticksScanned = false;
  }
  StateInline.prototype.pushPending = function() {
    var token = new Token("text", "", 0);
    token.content = this.pending;
    token.level = this.pendingLevel;
    this.tokens.push(token);
    this.pending = "";
    return token;
  };
  StateInline.prototype.push = function(type, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }
    var token = new Token(type, tag, nesting);
    var token_meta = null;
    if (nesting < 0) {
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }
    token.level = this.level;
    if (nesting > 0) {
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = {delimiters: this.delimiters};
    }
    this.pendingLevel = this.level;
    this.tokens.push(token);
    this.tokens_meta.push(token_meta);
    return token;
  };
  StateInline.prototype.scanDelims = function(start, canSplitWord) {
    var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
    lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
    while (pos < max && this.src.charCodeAt(pos) === marker) {
      pos++;
    }
    count = pos - start;
    nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
    isLastWhiteSpace = isWhiteSpace(lastChar);
    isNextWhiteSpace = isWhiteSpace(nextChar);
    if (isNextWhiteSpace) {
      left_flanking = false;
    } else if (isNextPunctChar) {
      if (!(isLastWhiteSpace || isLastPunctChar)) {
        left_flanking = false;
      }
    }
    if (isLastWhiteSpace) {
      right_flanking = false;
    } else if (isLastPunctChar) {
      if (!(isNextWhiteSpace || isNextPunctChar)) {
        right_flanking = false;
      }
    }
    if (!canSplitWord) {
      can_open = left_flanking && (!right_flanking || isLastPunctChar);
      can_close = right_flanking && (!left_flanking || isNextPunctChar);
    } else {
      can_open = left_flanking;
      can_close = right_flanking;
    }
    return {
      can_open,
      can_close,
      length: count
    };
  };
  StateInline.prototype.Token = Token;
  module2.exports = StateInline;
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS((exports2, module2) => {
  "use strict";
  var Ruler = require_ruler();
  var _rules = [
    ["text", require_text()],
    ["newline", require_newline()],
    ["escape", require_escape()],
    ["backticks", require_backticks()],
    ["strikethrough", require_strikethrough().tokenize],
    ["emphasis", require_emphasis().tokenize],
    ["link", require_link()],
    ["image", require_image()],
    ["autolink", require_autolink()],
    ["html_inline", require_html_inline()],
    ["entity", require_entity()]
  ];
  var _rules2 = [
    ["balance_pairs", require_balance_pairs()],
    ["strikethrough", require_strikethrough().postProcess],
    ["emphasis", require_emphasis().postProcess],
    ["text_collapse", require_text_collapse()]
  ];
  function ParserInline() {
    var i;
    this.ruler = new Ruler();
    for (i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
    this.ruler2 = new Ruler();
    for (i = 0; i < _rules2.length; i++) {
      this.ruler2.push(_rules2[i][0], _rules2[i][1]);
    }
  }
  ParserInline.prototype.skipToken = function(state) {
    var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
    if (typeof cache[pos] !== "undefined") {
      state.pos = cache[pos];
      return;
    }
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        state.level++;
        ok = rules[i](state, true);
        state.level--;
        if (ok) {
          break;
        }
      }
    } else {
      state.pos = state.posMax;
    }
    if (!ok) {
      state.pos++;
    }
    cache[pos] = state.pos;
  };
  ParserInline.prototype.tokenize = function(state) {
    var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
    while (state.pos < end) {
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          ok = rules[i](state, false);
          if (ok) {
            break;
          }
        }
      }
      if (ok) {
        if (state.pos >= end) {
          break;
        }
        continue;
      }
      state.pending += state.src[state.pos++];
    }
    if (state.pending) {
      state.pushPending();
    }
  };
  ParserInline.prototype.parse = function(str, md, env, outTokens) {
    var i, rules, len;
    var state = new this.State(str, md, env, outTokens);
    this.tokenize(state);
    rules = this.ruler2.getRules("");
    len = rules.length;
    for (i = 0; i < len; i++) {
      rules[i](state);
    }
  };
  ParserInline.prototype.State = require_state_inline();
  module2.exports = ParserInline;
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(opts) {
    var re = {};
    re.src_Any = require_regex2().source;
    re.src_Cc = require_regex3().source;
    re.src_Z = require_regex5().source;
    re.src_P = require_regex().source;
    re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
    re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
    var text_separators = "[><\uFF5C]";
    re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
    re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
    re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
    re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
    re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
    re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
    re.src_xn = "xn--[a-z0-9\\-]{1,59}";
    re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
    re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
    re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
    re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
    re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
    re.src_host_strict = re.src_host + re.src_host_terminator;
    re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
    re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
    re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
    re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
    re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
    re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
    re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
    re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
    return re;
  };
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS((exports2, module2) => {
  "use strict";
  function assign(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString(obj) {
    return _class(obj) === "[object String]";
  }
  function isObject(obj) {
    return _class(obj) === "[object Object]";
  }
  function isRegExp(obj) {
    return _class(obj) === "[object RegExp]";
  }
  function isFunction(obj) {
    return _class(obj) === "[object Function]";
  }
  function escapeRE(str) {
    return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var defaultOptions = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };
  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function(acc, k) {
      return acc || defaultOptions.hasOwnProperty(k);
    }, false);
  }
  var defaultSchemas = {
    "http:": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.http) {
          self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
        }
        if (self.re.http.test(tail)) {
          return tail.match(self.re.http)[0].length;
        }
        return 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.no_http) {
          self.re.no_http = new RegExp("^" + self.re.src_auth + "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, "i");
        }
        if (self.re.no_http.test(tail)) {
          if (pos >= 3 && text[pos - 3] === ":") {
            return 0;
          }
          if (pos >= 3 && text[pos - 3] === "/") {
            return 0;
          }
          return tail.match(self.re.no_http)[0].length;
        }
        return 0;
      }
    },
    "mailto:": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.mailto) {
          self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
        }
        if (self.re.mailto.test(tail)) {
          return tail.match(self.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };
  var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
  var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
  function resetScanCache(self) {
    self.__index__ = -1;
    self.__text_cache__ = "";
  }
  function createValidator(re) {
    return function(text, pos) {
      var tail = text.slice(pos);
      if (re.test(tail)) {
        return tail.match(re)[0].length;
      }
      return 0;
    };
  }
  function createNormalizer() {
    return function(match, self) {
      self.normalize(match);
    };
  }
  function compile(self) {
    var re = self.re = require_re()(self.__opts__);
    var tlds = self.__tlds__.slice();
    self.onCompile();
    if (!self.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }
    tlds.push(re.src_xn);
    re.src_tlds = tlds.join("|");
    function untpl(tpl) {
      return tpl.replace("%TLDS%", re.src_tlds);
    }
    re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
    re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
    re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
    re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
    var aliases = [];
    self.__compiled__ = {};
    function schemaError(name, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
    }
    Object.keys(self.__schemas__).forEach(function(name) {
      var val = self.__schemas__[name];
      if (val === null) {
        return;
      }
      var compiled = {validate: null, link: null};
      self.__compiled__[name] = compiled;
      if (isObject(val)) {
        if (isRegExp(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name, val);
        }
        if (isFunction(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name, val);
        }
        return;
      }
      if (isString(val)) {
        aliases.push(name);
        return;
      }
      schemaError(name, val);
    });
    aliases.forEach(function(alias) {
      if (!self.__compiled__[self.__schemas__[alias]]) {
        return;
      }
      self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
      self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
    });
    self.__compiled__[""] = {validate: null, normalize: createNormalizer()};
    var slist = Object.keys(self.__compiled__).filter(function(name) {
      return name.length > 0 && self.__compiled__[name];
    }).map(escapeRE).join("|");
    self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
    self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
    self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@", "i");
    resetScanCache(self);
  }
  function Match(self, shift) {
    var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);
    this.schema = self.__schema__.toLowerCase();
    this.index = start + shift;
    this.lastIndex = end + shift;
    this.raw = text;
    this.text = text;
    this.url = text;
  }
  function createMatch(self, shift) {
    var match = new Match(self, shift);
    self.__compiled__[match.schema].normalize(match, self);
    return match;
  }
  function LinkifyIt(schemas, options) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas, options);
    }
    if (!options) {
      if (isOptionsObj(schemas)) {
        options = schemas;
        schemas = {};
      }
    }
    this.__opts__ = assign({}, defaultOptions, options);
    this.__index__ = -1;
    this.__last_index__ = -1;
    this.__schema__ = "";
    this.__text_cache__ = "";
    this.__schemas__ = assign({}, defaultSchemas, schemas);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile(this);
  }
  LinkifyIt.prototype.add = function add(schema, definition) {
    this.__schemas__[schema] = definition;
    compile(this);
    return this;
  };
  LinkifyIt.prototype.set = function set(options) {
    this.__opts__ = assign(this.__opts__, options);
    return this;
  };
  LinkifyIt.prototype.test = function test(text) {
    this.__text_cache__ = text;
    this.__index__ = -1;
    if (!text.length) {
      return false;
    }
    var m, ml, me, len, shift, next, re, tld_pos, at_pos;
    if (this.re.schema_test.test(text)) {
      re = this.re.schema_search;
      re.lastIndex = 0;
      while ((m = re.exec(text)) !== null) {
        len = this.testSchemaAt(text, m[2], re.lastIndex);
        if (len) {
          this.__schema__ = m[2];
          this.__index__ = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }
    if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
      tld_pos = text.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml.index + ml[1].length;
            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = "";
              this.__index__ = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }
    if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
      at_pos = text.indexOf("@");
      if (at_pos >= 0) {
        if ((me = text.match(this.re.email_fuzzy)) !== null) {
          shift = me.index + me[1].length;
          next = me.index + me[0].length;
          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
            this.__schema__ = "mailto:";
            this.__index__ = shift;
            this.__last_index__ = next;
          }
        }
      }
    }
    return this.__index__ >= 0;
  };
  LinkifyIt.prototype.pretest = function pretest(text) {
    return this.re.pretest.test(text);
  };
  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
    if (!this.__compiled__[schema.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
  };
  LinkifyIt.prototype.match = function match(text) {
    var shift = 0, result = [];
    if (this.__index__ >= 0 && this.__text_cache__ === text) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }
    var tail = shift ? text.slice(shift) : text;
    while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }
    if (result.length) {
      return result;
    }
    return null;
  };
  LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
    list = Array.isArray(list) ? list : [list];
    if (!keepOld) {
      this.__tlds__ = list.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }
    this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
      return el !== arr[idx - 1];
    }).reverse();
    compile(this);
    return this;
  };
  LinkifyIt.prototype.normalize = function normalize(match) {
    if (!match.schema) {
      match.url = "http://" + match.url;
    }
    if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
      match.url = "mailto:" + match.url;
    }
  };
  LinkifyIt.prototype.onCompile = function onCompile() {
  };
  module2.exports = LinkifyIt;
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    options: {
      html: false,
      xhtmlOut: false,
      breaks: false,
      langPrefix: "language-",
      linkify: false,
      typographer: false,
      quotes: "\u201C\u201D\u2018\u2019",
      highlight: null,
      maxNesting: 100
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    options: {
      html: false,
      xhtmlOut: false,
      breaks: false,
      langPrefix: "language-",
      linkify: false,
      typographer: false,
      quotes: "\u201C\u201D\u2018\u2019",
      highlight: null,
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline"
        ]
      },
      block: {
        rules: [
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "text"
        ],
        rules2: [
          "balance_pairs",
          "text_collapse"
        ]
      }
    }
  };
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    options: {
      html: true,
      xhtmlOut: true,
      breaks: false,
      langPrefix: "language-",
      linkify: false,
      typographer: false,
      quotes: "\u201C\u201D\u2018\u2019",
      highlight: null,
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline"
        ]
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text"
        ],
        rules2: [
          "balance_pairs",
          "emphasis",
          "text_collapse"
        ]
      }
    }
  };
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var helpers = require_helpers();
  var Renderer = require_renderer();
  var ParserCore = require_parser_core();
  var ParserBlock = require_parser_block();
  var ParserInline = require_parser_inline();
  var LinkifyIt = require_linkify_it();
  var mdurl = require_mdurl();
  var punycode = require("punycode");
  var config2 = {
    default: require_default(),
    zero: require_zero(),
    commonmark: require_commonmark()
  };
  var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
  function validateLink(url) {
    var str = url.trim().toLowerCase();
    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
  }
  var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
  function normalizeLink(url) {
    var parsed = mdurl.parse(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toASCII(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return mdurl.encode(mdurl.format(parsed));
  }
  function normalizeLinkText(url) {
    var parsed = mdurl.parse(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toUnicode(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
  }
  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }
    if (!options) {
      if (!utils.isString(presetName)) {
        options = presetName || {};
        presetName = "default";
      }
    }
    this.inline = new ParserInline();
    this.block = new ParserBlock();
    this.core = new ParserCore();
    this.renderer = new Renderer();
    this.linkify = new LinkifyIt();
    this.validateLink = validateLink;
    this.normalizeLink = normalizeLink;
    this.normalizeLinkText = normalizeLinkText;
    this.utils = utils;
    this.helpers = utils.assign({}, helpers);
    this.options = {};
    this.configure(presetName);
    if (options) {
      this.set(options);
    }
  }
  MarkdownIt.prototype.set = function(options) {
    utils.assign(this.options, options);
    return this;
  };
  MarkdownIt.prototype.configure = function(presets) {
    var self = this, presetName;
    if (utils.isString(presets)) {
      presetName = presets;
      presets = config2[presetName];
      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }
    if (!presets) {
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    }
    if (presets.options) {
      self.set(presets.options);
    }
    if (presets.components) {
      Object.keys(presets.components).forEach(function(name) {
        if (presets.components[name].rules) {
          self[name].ruler.enableOnly(presets.components[name].rules);
        }
        if (presets.components[name].rules2) {
          self[name].ruler2.enableOnly(presets.components[name].rules2);
        }
      });
    }
    return this;
  };
  MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list)) {
      list = [list];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.enable(list, true));
    }, this);
    result = result.concat(this.inline.ruler2.enable(list, true));
    var missed = list.filter(function(name) {
      return result.indexOf(name) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list)) {
      list = [list];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.disable(list, true));
    }, this);
    result = result.concat(this.inline.ruler2.disable(list, true));
    var missed = list.filter(function(name) {
      return result.indexOf(name) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.use = function(plugin) {
    var args = [this].concat(Array.prototype.slice.call(arguments, 1));
    plugin.apply(plugin, args);
    return this;
  };
  MarkdownIt.prototype.parse = function(src, env) {
    if (typeof src !== "string") {
      throw new Error("Input data should be a String");
    }
    var state = new this.core.State(src, this, env);
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.render = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parse(src, env), this.options, env);
  };
  MarkdownIt.prototype.parseInline = function(src, env) {
    var state = new this.core.State(src, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.renderInline = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };
  module2.exports = MarkdownIt;
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_lib();
});

// node_modules/markdownlint/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "markdownlint",
    version: "0.23.1",
    description: "A Node.js style checker and lint tool for Markdown/CommonMark files.",
    main: "lib/markdownlint.js",
    types: "lib/markdownlint.d.ts",
    author: "David Anson (https://dlaa.me/)",
    license: "MIT",
    homepage: "https://github.com/DavidAnson/markdownlint",
    repository: {
      type: "git",
      url: "https://github.com/DavidAnson/markdownlint.git"
    },
    bugs: "https://github.com/DavidAnson/markdownlint/issues",
    scripts: {
      "build-config": "npm run build-config-schema && npm run build-config-example",
      "build-config-example": "node schema/build-config-example.js",
      "build-config-schema": "node schema/build-config-schema.js",
      "build-declaration": "tsc --allowJs --declaration --emitDeclarationOnly --resolveJsonModule lib/markdownlint.js && rimraf 'lib/{c,md,r}*.d.ts' 'helpers/*.d.ts'",
      "build-demo": "cpy node_modules/markdown-it/dist/markdown-it.min.js demo && cd demo && rimraf markdownlint-browser.* && webpack --no-stats",
      "build-example": "npm install --no-save --ignore-scripts grunt grunt-cli gulp through2",
      ci: "npm-run-all --continue-on-error --parallel test-cover lint declaration build-config build-demo && git diff --exit-code",
      "clean-test-repos": "rimraf test-repos",
      "clone-test-repos": "mkdir test-repos && cd test-repos && git clone https://github.com/eslint/eslint eslint-eslint --depth 1 --no-tags --quiet && git clone https://github.com/mkdocs/mkdocs mkdocs-mkdocs --depth 1 --no-tags --quiet && git clone https://github.com/pi-hole/docs pi-hole-docs --depth 1 --no-tags --quiet",
      "clone-test-repos-large": "npm run clone-test-repos && cd test-repos && git clone https://github.com/dotnet/docs dotnet-docs --depth 1 --no-tags --quiet",
      declaration: "npm run build-declaration && npm run test-declaration",
      example: "cd example && node standalone.js && grunt markdownlint --force && gulp markdownlint",
      lint: "eslint --max-warnings 0 .",
      "lint-test-repos": "ava --timeout=5m test/markdownlint-test-repos.js",
      test: "ava test/markdownlint-test.js test/markdownlint-test-custom-rules.js test/markdownlint-test-helpers.js test/markdownlint-test-result-object.js test/markdownlint-test-scenarios.js",
      "test-cover": "c8 --check-coverage --branches 100 --functions 100 --lines 100 --statements 100 npm test",
      "test-declaration": "cd example/typescript && tsc && node type-check.js",
      "test-extra": "ava --timeout=5m test/markdownlint-test-extra.js"
    },
    engines: {
      node: ">=10"
    },
    dependencies: {
      "markdown-it": "12.0.4"
    },
    devDependencies: {
      ava: "~3.15.0",
      c8: "~7.5.0",
      "cpy-cli": "~3.1.1",
      eslint: "~7.19.0",
      "eslint-plugin-jsdoc": "~31.6.0",
      "eslint-plugin-node": "~11.1.0",
      "eslint-plugin-unicorn": "~27.0.0",
      globby: "~11.0.2",
      "js-yaml": "~4.0.0",
      "markdown-it-for-inline": "~0.1.1",
      "markdown-it-sub": "~1.0.0",
      "markdown-it-sup": "~1.0.0",
      "markdown-it-texmath": "~0.8.0",
      "markdownlint-rule-helpers": "~0.13.0",
      "npm-run-all": "~4.1.5",
      rimraf: "~3.0.2",
      "strip-json-comments": "~3.1.1",
      toml: "~3.0.0",
      "ts-loader": "~8.0.15",
      tv4: "~1.3.0",
      typescript: "~4.1.3",
      webpack: "~5.21.1",
      "webpack-cli": "~4.5.0"
    },
    keywords: [
      "markdown",
      "lint",
      "md",
      "CommonMark",
      "markdownlint"
    ]
  };
});

// node_modules/markdownlint/helpers/helpers.js
var require_helpers2 = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var newLineRe = /\r\n?|\n/g;
  module2.exports.newLineRe = newLineRe;
  module2.exports.frontMatterRe = /((^---\s*$[^]*?^---\s*$)|(^\+\+\+\s*$[^]*?^(\+\+\+|\.\.\.)\s*$)|(^\{\s*$[^]*?^\}\s*$))(\r\n|\r|\n|$)/m;
  var inlineCommentRe = /<!--\s*markdownlint-(?:(?:(disable|enable|capture|restore|disable-file|enable-file|disable-next-line)((?:\s+[a-z0-9_-]+)*))|(?:(configure-file)\s+([\s\S]*?)))\s*-->/ig;
  module2.exports.inlineCommentRe = inlineCommentRe;
  module2.exports.bareUrlRe = /(?:http|ftp)s?:\/\/[^\s\]"']*(?:\/|[^\s\]"'\W])/ig;
  module2.exports.listItemMarkerRe = /^([\s>]*)(?:[*+-]|\d+[.)])\s+/;
  module2.exports.orderedListItemMarkerRe = /^[\s>]*0*(\d+)[.)]/;
  var emphasisMarkersRe = /[_*]/g;
  var linkRe = /\[(?:[^[\]]|\[[^\]]*\])*\](?:\(\S*\))?/g;
  module2.exports.utf8Encoding = "utf8";
  var allPunctuation = ".,;:!?\u3002\uFF0C\uFF1B\uFF1A\uFF01\uFF1F";
  module2.exports.allPunctuation = allPunctuation;
  module2.exports.allPunctuationNoQuestion = allPunctuation.replace(/[?？]/gu, "");
  module2.exports.isNumber = function isNumber(obj) {
    return typeof obj === "number";
  };
  module2.exports.isString = function isString(obj) {
    return typeof obj === "string";
  };
  module2.exports.isEmptyString = function isEmptyString(str) {
    return str.length === 0;
  };
  module2.exports.isObject = function isObject(obj) {
    return obj !== null && typeof obj === "object" && !Array.isArray(obj);
  };
  var blankLineRe = />|(?:<!--.*?-->)/g;
  module2.exports.isBlankLine = function isBlankLine(line) {
    return !line || !line.trim() || !line.replace(blankLineRe, "").trim();
  };
  module2.exports.numericSortAscending = function numericSortAscending(a, b) {
    return a - b;
  };
  module2.exports.includesSorted = function includesSorted(array, element) {
    let left = 0;
    let right = array.length - 1;
    while (left <= right) {
      const mid = left + right >> 1;
      if (array[mid] < element) {
        left = mid + 1;
      } else if (array[mid] > element) {
        right = mid - 1;
      } else {
        return true;
      }
    }
    return false;
  };
  var htmlCommentBegin = "<!--";
  var htmlCommentEnd = "-->";
  module2.exports.clearHtmlCommentText = function clearHtmlCommentText(text) {
    let i = 0;
    while ((i = text.indexOf(htmlCommentBegin, i)) !== -1) {
      const j = text.indexOf(htmlCommentEnd, i + 2);
      if (j === -1) {
        break;
      }
      if (j > i + htmlCommentBegin.length) {
        let k = i - 1;
        while (text[k] === " ") {
          k--;
        }
        if (k >= i - 4) {
          const content = text.slice(i + htmlCommentBegin.length, j);
          const isBlock = k < 0 || text[k] === "\n";
          const isValid = isBlock || !content.startsWith(">") && !content.startsWith("->") && !content.endsWith("-") && !content.includes("--");
          if (isValid) {
            const inlineCommentIndex = text.slice(i, j + htmlCommentEnd.length).search(inlineCommentRe);
            if (inlineCommentIndex === -1) {
              text = text.slice(0, i + htmlCommentBegin.length) + content.replace(/[^\r\n]/g, ".") + text.slice(j);
            }
          }
        }
      }
      i = j + htmlCommentEnd.length;
    }
    return text;
  };
  module2.exports.escapeForRegExp = function escapeForRegExp(str) {
    return str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  };
  var escapedMarkdownRe = /\\./g;
  module2.exports.unescapeMarkdown = function unescapeMarkdown(markdown, replacement) {
    return markdown.replace(escapedMarkdownRe, (match) => {
      const char = match[1];
      if ("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~".includes(char)) {
        return replacement || char;
      }
      return match;
    });
  };
  module2.exports.fencedCodeBlockStyleFor = function fencedCodeBlockStyleFor(markup) {
    switch (markup[0]) {
      case "~":
        return "tilde";
      default:
        return "backtick";
    }
  };
  function indentFor(token) {
    const line = token.line.replace(/^[\s>]*(> |>)/, "");
    return line.length - line.trimStart().length;
  }
  module2.exports.indentFor = indentFor;
  module2.exports.headingStyleFor = function headingStyleFor(token) {
    if (token.map[1] - token.map[0] === 1) {
      if (/[^\\]#\s*$/.test(token.line)) {
        return "atx_closed";
      }
      return "atx";
    }
    return "setext";
  };
  module2.exports.unorderedListStyleFor = function unorderedListStyleFor(token) {
    switch (token.markup) {
      case "-":
        return "dash";
      case "+":
        return "plus";
      default:
        return "asterisk";
    }
  };
  function filterTokens(params, type, handler) {
    params.tokens.forEach(function forToken(token) {
      if (token.type === type) {
        handler(token);
      }
    });
  }
  module2.exports.filterTokens = filterTokens;
  function isMathBlock(token) {
    return token.tag === "math" && token.type.startsWith("math_block") && !token.type.endsWith("_end");
  }
  module2.exports.getLineMetadata = function getLineMetadata(params) {
    const lineMetadata = params.lines.map((line, index) => [line, index, false, 0, false, false, false, false]);
    filterTokens(params, "fence", (token) => {
      lineMetadata[token.map[0]][3] = 1;
      lineMetadata[token.map[1] - 1][3] = -1;
      for (let i = token.map[0] + 1; i < token.map[1] - 1; i++) {
        lineMetadata[i][2] = true;
      }
    });
    filterTokens(params, "code_block", (token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][2] = true;
      }
    });
    filterTokens(params, "table_open", (token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][4] = true;
      }
    });
    filterTokens(params, "list_item_open", (token) => {
      let count = 1;
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][5] = count;
        count++;
      }
    });
    filterTokens(params, "hr", (token) => {
      lineMetadata[token.map[0]][6] = true;
    });
    params.tokens.filter(isMathBlock).forEach((token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][7] = true;
      }
    });
    return lineMetadata;
  };
  module2.exports.forEachLine = function forEachLine(lineMetadata, handler) {
    lineMetadata.forEach(function forMetadata(metadata) {
      handler(...metadata);
    });
  };
  module2.exports.flattenLists = function flattenLists(params) {
    const flattenedLists = [];
    const stack = [];
    let current = null;
    let nesting = 0;
    const nestingStack = [];
    let lastWithMap = {map: [0, 1]};
    params.tokens.forEach((token) => {
      if (isMathBlock(token) && token.map[1]) {
        token.map[1]++;
      }
      if (token.type === "bullet_list_open" || token.type === "ordered_list_open") {
        stack.push(current);
        current = {
          unordered: token.type === "bullet_list_open",
          parentsUnordered: !current || current.unordered && current.parentsUnordered,
          open: token,
          indent: indentFor(token),
          parentIndent: current && current.indent || 0,
          items: [],
          nesting,
          lastLineIndex: -1,
          insert: flattenedLists.length
        };
        nesting++;
      } else if (token.type === "bullet_list_close" || token.type === "ordered_list_close") {
        current.lastLineIndex = lastWithMap.map[1];
        flattenedLists.splice(current.insert, 0, current);
        delete current.insert;
        current = stack.pop();
        nesting--;
      } else if (token.type === "list_item_open") {
        current.items.push(token);
      } else if (token.type === "blockquote_open") {
        nestingStack.push(nesting);
        nesting = 0;
      } else if (token.type === "blockquote_close") {
        nesting = nestingStack.pop();
      } else if (token.map) {
        lastWithMap = token;
      }
    });
    return flattenedLists;
  };
  module2.exports.forEachInlineChild = function forEachInlineChild(params, type, handler) {
    filterTokens(params, "inline", function forToken(token) {
      token.children.forEach(function forChild(child) {
        if (child.type === type) {
          handler(child, token);
        }
      });
    });
  };
  module2.exports.forEachHeading = function forEachHeading(params, handler) {
    let heading = null;
    params.tokens.forEach(function forToken(token) {
      if (token.type === "heading_open") {
        heading = token;
      } else if (token.type === "heading_close") {
        heading = null;
      } else if (token.type === "inline" && heading) {
        handler(heading, token.content);
      }
    });
  };
  function forEachInlineCodeSpan(input, handler) {
    let currentLine = 0;
    let currentColumn = 0;
    let index = 0;
    while (index < input.length) {
      let startIndex = -1;
      let startLine = -1;
      let startColumn = -1;
      let tickCount = 0;
      let currentTicks = 0;
      let state = "normal";
      for (; index <= input.length; index++) {
        const char = input[index];
        if (char === "[" && state === "normal") {
          state = "linkTextOpen";
        } else if (char === "]" && state === "linkTextOpen") {
          state = "linkTextClosed";
        } else if (char === "(" && state === "linkTextClosed") {
          state = "linkDestinationOpen";
        } else if (char === "(" && state === "linkDestinationOpen" || char === ")" && state === "linkDestinationOpen" || state === "linkTextClosed") {
          state = "normal";
        }
        if (char === "`" && state !== "linkDestinationOpen") {
          currentTicks++;
          if (startIndex === -1 || startColumn === -1) {
            startIndex = index + 1;
          }
        } else {
          if (startIndex >= 0 && startColumn >= 0 && tickCount === currentTicks) {
            handler(input.substring(startIndex, index - currentTicks), startLine, startColumn, tickCount);
            startIndex = -1;
            startColumn = -1;
          } else if (startIndex >= 0 && startColumn === -1) {
            tickCount = currentTicks;
            startLine = currentLine;
            startColumn = currentColumn;
          }
          currentTicks = 0;
        }
        if (char === "\n") {
          currentLine++;
          currentColumn = 0;
        } else if (char === "\\" && (startIndex === -1 || startColumn === -1) && input[index + 1] !== "\n") {
          index++;
          currentColumn += 2;
        } else {
          currentColumn++;
        }
      }
      if (startIndex >= 0) {
        index = startIndex;
        currentLine = startLine;
        currentColumn = startColumn;
      }
    }
  }
  module2.exports.forEachInlineCodeSpan = forEachInlineCodeSpan;
  function addError(onError, lineNumber, detail, context, range, fixInfo) {
    onError({
      lineNumber,
      detail,
      context,
      range,
      fixInfo
    });
  }
  module2.exports.addError = addError;
  module2.exports.addErrorDetailIf = function addErrorDetailIf(onError, lineNumber, expected, actual, detail, context, range, fixInfo) {
    if (expected !== actual) {
      addError(onError, lineNumber, "Expected: " + expected + "; Actual: " + actual + (detail ? "; " + detail : ""), context, range, fixInfo);
    }
  };
  module2.exports.addErrorContext = function addErrorContext(onError, lineNumber, context, left, right, range, fixInfo) {
    if (context.length <= 30) {
    } else if (left && right) {
      context = context.substr(0, 15) + "..." + context.substr(-15);
    } else if (right) {
      context = "..." + context.substr(-30);
    } else {
      context = context.substr(0, 30) + "...";
    }
    addError(onError, lineNumber, null, context, range, fixInfo);
  };
  module2.exports.rangeFromRegExp = function rangeFromRegExp(line, regexp) {
    let range = null;
    const match = line.match(regexp);
    if (match) {
      const column = match.index + 1;
      const length = match[0].length;
      range = [column, length];
    }
    return range;
  };
  module2.exports.frontMatterHasTitle = function frontMatterHasTitle(frontMatterLines, frontMatterTitlePattern) {
    const ignoreFrontMatter = frontMatterTitlePattern !== void 0 && !frontMatterTitlePattern;
    const frontMatterTitleRe = new RegExp(String(frontMatterTitlePattern || '^\\s*"?title"?\\s*[:=]'), "i");
    return !ignoreFrontMatter && frontMatterLines.some((line) => frontMatterTitleRe.test(line));
  };
  function emphasisMarkersInContent(params) {
    const {lines} = params;
    const byLine = new Array(lines.length);
    filterTokens(params, "inline", (token) => {
      const {children, lineNumber, map} = token;
      if (children.some((child) => child.type === "code_inline")) {
        const tokenLines = lines.slice(map[0], map[1]);
        forEachInlineCodeSpan(tokenLines.join("\n"), (code, lineIndex, column, tickCount) => {
          const codeLines = code.split(newLineRe);
          codeLines.forEach((codeLine, codeLineIndex) => {
            let match = null;
            while (match = emphasisMarkersRe.exec(codeLine)) {
              const byLineIndex = lineNumber - 1 + lineIndex + codeLineIndex;
              const inLine = byLine[byLineIndex] || [];
              const codeLineOffset = codeLineIndex ? 0 : column - 1 + tickCount;
              inLine.push(codeLineOffset + match.index);
              byLine[byLineIndex] = inLine;
            }
          });
        });
      }
    });
    lines.forEach((tokenLine, tokenLineIndex) => {
      let linkMatch = null;
      while (linkMatch = linkRe.exec(tokenLine)) {
        let markerMatch = null;
        while (markerMatch = emphasisMarkersRe.exec(linkMatch[0])) {
          const inLine = byLine[tokenLineIndex] || [];
          inLine.push(linkMatch.index + markerMatch.index);
          byLine[tokenLineIndex] = inLine;
        }
      }
    });
    return byLine;
  }
  module2.exports.emphasisMarkersInContent = emphasisMarkersInContent;
  function getPreferredLineEnding(input) {
    let cr = 0;
    let lf = 0;
    let crlf = 0;
    const endings = input.match(newLineRe) || [];
    endings.forEach((ending) => {
      switch (ending) {
        case "\r":
          cr++;
          break;
        case "\n":
          lf++;
          break;
        case "\r\n":
          crlf++;
          break;
      }
    });
    let preferredLineEnding = null;
    if (!cr && !lf && !crlf) {
      preferredLineEnding = os.EOL;
    } else if (lf >= crlf && lf >= cr) {
      preferredLineEnding = "\n";
    } else if (crlf >= cr) {
      preferredLineEnding = "\r\n";
    } else {
      preferredLineEnding = "\r";
    }
    return preferredLineEnding;
  }
  module2.exports.getPreferredLineEnding = getPreferredLineEnding;
  function normalizeFixInfo(fixInfo, lineNumber) {
    return {
      lineNumber: fixInfo.lineNumber || lineNumber,
      editColumn: fixInfo.editColumn || 1,
      deleteCount: fixInfo.deleteCount || 0,
      insertText: fixInfo.insertText || ""
    };
  }
  function applyFix2(line, fixInfo, lineEnding) {
    const {editColumn, deleteCount, insertText} = normalizeFixInfo(fixInfo);
    const editIndex = editColumn - 1;
    return deleteCount === -1 ? null : line.slice(0, editIndex) + insertText.replace(/\n/g, lineEnding || "\n") + line.slice(editIndex + deleteCount);
  }
  module2.exports.applyFix = applyFix2;
  module2.exports.applyFixes = function applyFixes2(input, errors) {
    const lineEnding = getPreferredLineEnding(input);
    const lines = input.split(newLineRe);
    let fixInfos = errors.filter((error) => error.fixInfo).map((error) => normalizeFixInfo(error.fixInfo, error.lineNumber));
    fixInfos.sort((a, b) => {
      const aDeletingLine = a.deleteCount === -1;
      const bDeletingLine = b.deleteCount === -1;
      return b.lineNumber - a.lineNumber || (aDeletingLine ? 1 : bDeletingLine ? -1 : 0) || b.editColumn - a.editColumn || b.insertText.length - a.insertText.length;
    });
    let lastFixInfo = {};
    fixInfos = fixInfos.filter((fixInfo) => {
      const unique = fixInfo.lineNumber !== lastFixInfo.lineNumber || fixInfo.editColumn !== lastFixInfo.editColumn || fixInfo.deleteCount !== lastFixInfo.deleteCount || fixInfo.insertText !== lastFixInfo.insertText;
      lastFixInfo = fixInfo;
      return unique;
    });
    lastFixInfo = {};
    fixInfos.forEach((fixInfo) => {
      if (fixInfo.lineNumber === lastFixInfo.lineNumber && fixInfo.editColumn === lastFixInfo.editColumn && !fixInfo.insertText && fixInfo.deleteCount > 0 && lastFixInfo.insertText && !lastFixInfo.deleteCount) {
        fixInfo.insertText = lastFixInfo.insertText;
        lastFixInfo.lineNumber = 0;
      }
      lastFixInfo = fixInfo;
    });
    fixInfos = fixInfos.filter((fixInfo) => fixInfo.lineNumber);
    let lastLineIndex = -1;
    let lastEditIndex = -1;
    fixInfos.forEach((fixInfo) => {
      const {lineNumber, editColumn, deleteCount} = fixInfo;
      const lineIndex = lineNumber - 1;
      const editIndex = editColumn - 1;
      if (lineIndex !== lastLineIndex || deleteCount === -1 || editIndex + deleteCount <= lastEditIndex - (deleteCount > 0 ? 0 : 1)) {
        lines[lineIndex] = applyFix2(lines[lineIndex], fixInfo, lineEnding);
      }
      lastLineIndex = lineIndex;
      lastEditIndex = editIndex;
    });
    return lines.filter((line) => line !== null).join(lineEnding);
  };
});

// node_modules/markdownlint/lib/md001.js
var require_md001 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, filterTokens} = require_helpers2();
  module2.exports = {
    names: ["MD001", "heading-increment", "header-increment"],
    description: "Heading levels should only increment by one level at a time",
    tags: ["headings", "headers"],
    function: function MD001(params, onError) {
      let prevLevel = 0;
      filterTokens(params, "heading_open", function forToken(token) {
        const level = Number.parseInt(token.tag.slice(1), 10);
        if (prevLevel && level > prevLevel) {
          addErrorDetailIf(onError, token.lineNumber, "h" + (prevLevel + 1), "h" + level);
        }
        prevLevel = level;
      });
    }
  };
});

// node_modules/markdownlint/lib/md002.js
var require_md002 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf} = require_helpers2();
  module2.exports = {
    names: ["MD002", "first-heading-h1", "first-header-h1"],
    description: "First heading should be a top-level heading",
    tags: ["headings", "headers"],
    function: function MD002(params, onError) {
      const level = Number(params.config.level || 1);
      const tag = "h" + level;
      params.tokens.every(function forToken(token) {
        if (token.type === "heading_open") {
          addErrorDetailIf(onError, token.lineNumber, tag, token.tag);
          return false;
        }
        return true;
      });
    }
  };
});

// node_modules/markdownlint/lib/md003.js
var require_md003 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, filterTokens, headingStyleFor} = require_helpers2();
  module2.exports = {
    names: ["MD003", "heading-style", "header-style"],
    description: "Heading style",
    tags: ["headings", "headers"],
    function: function MD003(params, onError) {
      let style = String(params.config.style || "consistent");
      filterTokens(params, "heading_open", function forToken(token) {
        const styleForToken = headingStyleFor(token);
        if (style === "consistent") {
          style = styleForToken;
        }
        if (styleForToken !== style) {
          const h12 = /h[12]/.test(token.tag);
          const setextWithAtx = style === "setext_with_atx" && (h12 && styleForToken === "setext" || !h12 && styleForToken === "atx");
          const setextWithAtxClosed = style === "setext_with_atx_closed" && (h12 && styleForToken === "setext" || !h12 && styleForToken === "atx_closed");
          if (!setextWithAtx && !setextWithAtxClosed) {
            let expected = style;
            if (style === "setext_with_atx") {
              expected = h12 ? "setext" : "atx";
            } else if (style === "setext_with_atx_closed") {
              expected = h12 ? "setext" : "atx_closed";
            }
            addErrorDetailIf(onError, token.lineNumber, expected, styleForToken);
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/cache.js
var require_cache = __commonJS((exports2, module2) => {
  "use strict";
  var lineMetadata = null;
  module2.exports.lineMetadata = (value) => {
    if (value) {
      lineMetadata = value;
    }
    return lineMetadata;
  };
  var flattenedLists = null;
  module2.exports.flattenedLists = (value) => {
    if (value) {
      flattenedLists = value;
    }
    return flattenedLists;
  };
  module2.exports.clear = () => {
    lineMetadata = null;
    flattenedLists = null;
  };
});

// node_modules/markdownlint/lib/md004.js
var require_md004 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, listItemMarkerRe, unorderedListStyleFor} = require_helpers2();
  var {flattenedLists} = require_cache();
  var expectedStyleToMarker = {
    dash: "-",
    plus: "+",
    asterisk: "*"
  };
  var differentItemStyle = {
    dash: "plus",
    plus: "asterisk",
    asterisk: "dash"
  };
  var validStyles = Object.keys(expectedStyleToMarker);
  module2.exports = {
    names: ["MD004", "ul-style"],
    description: "Unordered list style",
    tags: ["bullet", "ul"],
    function: function MD004(params, onError) {
      const style = String(params.config.style || "consistent");
      let expectedStyle = style;
      const nestingStyles = [];
      flattenedLists().forEach((list) => {
        if (list.unordered) {
          if (expectedStyle === "consistent") {
            expectedStyle = unorderedListStyleFor(list.items[0]);
          }
          list.items.forEach((item) => {
            const itemStyle = unorderedListStyleFor(item);
            if (style === "sublist") {
              const nesting = list.nesting;
              if (!nestingStyles[nesting]) {
                nestingStyles[nesting] = itemStyle === nestingStyles[nesting - 1] ? differentItemStyle[itemStyle] : itemStyle;
              }
              expectedStyle = nestingStyles[nesting];
            }
            if (!validStyles.includes(expectedStyle)) {
              expectedStyle = validStyles[0];
            }
            let range = null;
            let fixInfo = null;
            const match = item.line.match(listItemMarkerRe);
            if (match) {
              const column = match.index + 1;
              const length = match[0].length;
              range = [column, length];
              fixInfo = {
                editColumn: match[1].length + 1,
                deleteCount: 1,
                insertText: expectedStyleToMarker[expectedStyle]
              };
            }
            addErrorDetailIf(onError, item.lineNumber, expectedStyle, itemStyle, null, null, range, fixInfo);
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md005.js
var require_md005 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    addError,
    addErrorDetailIf,
    indentFor,
    listItemMarkerRe,
    orderedListItemMarkerRe,
    rangeFromRegExp
  } = require_helpers2();
  var {flattenedLists} = require_cache();
  module2.exports = {
    names: ["MD005", "list-indent"],
    description: "Inconsistent indentation for list items at the same level",
    tags: ["bullet", "ul", "indentation"],
    function: function MD005(params, onError) {
      flattenedLists().forEach((list) => {
        const expectedIndent = list.indent;
        let expectedEnd = 0;
        let actualEnd = -1;
        let endMatching = false;
        list.items.forEach((item) => {
          const {line, lineNumber} = item;
          const actualIndent = indentFor(item);
          let match = null;
          if (list.unordered) {
            addErrorDetailIf(onError, lineNumber, expectedIndent, actualIndent, null, null, rangeFromRegExp(line, listItemMarkerRe));
          } else if (match = orderedListItemMarkerRe.exec(line)) {
            actualEnd = match[0].length;
            expectedEnd = expectedEnd || actualEnd;
            const markerLength = match[1].length + 1;
            if (expectedIndent !== actualIndent || endMatching) {
              if (expectedEnd === actualEnd) {
                endMatching = true;
              } else {
                const detail = endMatching ? `Expected: (${expectedEnd}); Actual: (${actualEnd})` : `Expected: ${expectedIndent}; Actual: ${actualIndent}`;
                const expected = endMatching ? expectedEnd - markerLength : expectedIndent;
                const actual = endMatching ? actualEnd - markerLength : actualIndent;
                addError(onError, lineNumber, detail, null, rangeFromRegExp(line, listItemMarkerRe), {
                  editColumn: Math.min(actual, expected) + 1,
                  deleteCount: Math.max(actual - expected, 0),
                  insertText: "".padEnd(Math.max(expected - actual, 0))
                });
              }
            }
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md006.js
var require_md006 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, listItemMarkerRe, rangeFromRegExp} = require_helpers2();
  var {flattenedLists} = require_cache();
  module2.exports = {
    names: ["MD006", "ul-start-left"],
    description: "Consider starting bulleted lists at the beginning of the line",
    tags: ["bullet", "ul", "indentation"],
    function: function MD006(params, onError) {
      flattenedLists().forEach((list) => {
        if (list.unordered && !list.nesting && list.indent !== 0) {
          list.items.forEach((item) => {
            const {lineNumber, line} = item;
            addErrorDetailIf(onError, lineNumber, 0, list.indent, null, null, rangeFromRegExp(line, listItemMarkerRe), {
              deleteCount: line.length - line.trimStart().length
            });
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md007.js
var require_md007 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, indentFor, listItemMarkerRe} = require_helpers2();
  var {flattenedLists} = require_cache();
  module2.exports = {
    names: ["MD007", "ul-indent"],
    description: "Unordered list indentation",
    tags: ["bullet", "ul", "indentation"],
    function: function MD007(params, onError) {
      const indent = Number(params.config.indent || 2);
      const startIndented = !!params.config.start_indented;
      flattenedLists().forEach((list) => {
        if (list.unordered && list.parentsUnordered) {
          list.items.forEach((item) => {
            const {lineNumber, line} = item;
            const expectedNesting = list.nesting + (startIndented ? 1 : 0);
            const expectedIndent = expectedNesting * indent;
            const actualIndent = indentFor(item);
            let range = null;
            let editColumn = 1;
            const match = line.match(listItemMarkerRe);
            if (match) {
              range = [1, match[0].length];
              editColumn += match[1].length - actualIndent;
            }
            addErrorDetailIf(onError, lineNumber, expectedIndent, actualIndent, null, null, range, {
              editColumn,
              deleteCount: actualIndent,
              insertText: "".padEnd(expectedIndent)
            });
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md009.js
var require_md009 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    addError,
    filterTokens,
    forEachInlineCodeSpan,
    forEachLine,
    includesSorted,
    newLineRe,
    numericSortAscending
  } = require_helpers2();
  var {lineMetadata} = require_cache();
  module2.exports = {
    names: ["MD009", "no-trailing-spaces"],
    description: "Trailing spaces",
    tags: ["whitespace"],
    function: function MD009(params, onError) {
      let brSpaces = params.config.br_spaces;
      brSpaces = Number(brSpaces === void 0 ? 2 : brSpaces);
      const listItemEmptyLines = !!params.config.list_item_empty_lines;
      const strict = !!params.config.strict;
      const listItemLineNumbers = [];
      if (listItemEmptyLines) {
        filterTokens(params, "list_item_open", (token) => {
          for (let i = token.map[0]; i < token.map[1]; i++) {
            listItemLineNumbers.push(i + 1);
          }
        });
        listItemLineNumbers.sort(numericSortAscending);
      }
      const paragraphLineNumbers = [];
      const codeInlineLineNumbers = [];
      if (strict) {
        filterTokens(params, "paragraph_open", (token) => {
          for (let i = token.map[0]; i < token.map[1] - 1; i++) {
            paragraphLineNumbers.push(i + 1);
          }
        });
        paragraphLineNumbers.sort(numericSortAscending);
        filterTokens(params, "inline", (token) => {
          if (token.children.some((child) => child.type === "code_inline")) {
            const tokenLines = params.lines.slice(token.map[0], token.map[1]);
            forEachInlineCodeSpan(tokenLines.join("\n"), (code, lineIndex) => {
              const codeLineCount = code.split(newLineRe).length;
              for (let i = 0; i < codeLineCount; i++) {
                codeInlineLineNumbers.push(token.lineNumber + lineIndex + i);
              }
            });
          }
        });
        codeInlineLineNumbers.sort(numericSortAscending);
      }
      const expected = brSpaces < 2 ? 0 : brSpaces;
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        const lineNumber = lineIndex + 1;
        const trailingSpaces = line.length - line.trimEnd().length;
        if (trailingSpaces && !inCode && !includesSorted(listItemLineNumbers, lineNumber) && (expected !== trailingSpaces || strict && (!includesSorted(paragraphLineNumbers, lineNumber) || includesSorted(codeInlineLineNumbers, lineNumber)))) {
          const column = line.length - trailingSpaces + 1;
          addError(onError, lineNumber, "Expected: " + (expected === 0 ? "" : "0 or ") + expected + "; Actual: " + trailingSpaces, null, [column, trailingSpaces], {
            editColumn: column,
            deleteCount: trailingSpaces
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md010.js
var require_md010 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, forEachLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  var tabRe = /\t+/g;
  module2.exports = {
    names: ["MD010", "no-hard-tabs"],
    description: "Hard tabs",
    tags: ["whitespace", "hard_tab"],
    function: function MD010(params, onError) {
      const codeBlocks = params.config.code_blocks;
      const includeCodeBlocks = codeBlocks === void 0 ? true : !!codeBlocks;
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        if (!inCode || includeCodeBlocks) {
          let match = null;
          while ((match = tabRe.exec(line)) !== null) {
            const column = match.index + 1;
            const length = match[0].length;
            addError(onError, lineIndex + 1, "Column: " + column, null, [column, length], {
              editColumn: column,
              deleteCount: length,
              insertText: "".padEnd(length)
            });
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md011.js
var require_md011 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, forEachInlineChild, unescapeMarkdown} = require_helpers2();
  var reversedLinkRe = /\(([^)]+)\)\[([^\]^][^\]]*)]/g;
  module2.exports = {
    names: ["MD011", "no-reversed-links"],
    description: "Reversed link syntax",
    tags: ["links"],
    function: function MD011(params, onError) {
      forEachInlineChild(params, "text", (token) => {
        const {lineNumber, content} = token;
        let match = null;
        while ((match = reversedLinkRe.exec(content)) !== null) {
          const [reversedLink, linkText, linkDestination] = match;
          const line = params.lines[lineNumber - 1];
          const column = unescapeMarkdown(line).indexOf(reversedLink) + 1;
          const length = reversedLink.length;
          const range = column ? [column, length] : null;
          const fixInfo = column ? {
            editColumn: column,
            deleteCount: length,
            insertText: `[${linkText}](${linkDestination})`
          } : null;
          addError(onError, lineNumber, reversedLink, null, range, fixInfo);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md012.js
var require_md012 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, forEachLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  module2.exports = {
    names: ["MD012", "no-multiple-blanks"],
    description: "Multiple consecutive blank lines",
    tags: ["whitespace", "blank_lines"],
    function: function MD012(params, onError) {
      const maximum = Number(params.config.maximum || 1);
      let count = 0;
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        count = inCode || line.trim().length > 0 ? 0 : count + 1;
        if (maximum < count) {
          addErrorDetailIf(onError, lineIndex + 1, maximum, count, null, null, null, {
            deleteCount: -1
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md013.js
var require_md013 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    addErrorDetailIf,
    filterTokens,
    forEachHeading,
    forEachLine,
    includesSorted
  } = require_helpers2();
  var {lineMetadata} = require_cache();
  var longLineRePrefix = "^.{";
  var longLineRePostfixRelaxed = "}.*\\s.*$";
  var longLineRePostfixStrict = "}.+$";
  var labelRe = /^\s*\[.*[^\\]]:/;
  var linkOrImageOnlyLineRe = /^[es]*(lT?L|I)[ES]*$/;
  var sternModeRe = /^([#>\s]*\s)?\S*$/;
  var tokenTypeMap = {
    em_open: "e",
    em_close: "E",
    image: "I",
    link_open: "l",
    link_close: "L",
    strong_open: "s",
    strong_close: "S",
    text: "T"
  };
  module2.exports = {
    names: ["MD013", "line-length"],
    description: "Line length",
    tags: ["line_length"],
    function: function MD013(params, onError) {
      const lineLength = Number(params.config.line_length || 80);
      const headingLineLength = Number(params.config.heading_line_length || lineLength);
      const codeLineLength = Number(params.config.code_block_line_length || lineLength);
      const strict = !!params.config.strict;
      const stern = !!params.config.stern;
      const longLineRePostfix = strict || stern ? longLineRePostfixStrict : longLineRePostfixRelaxed;
      const longLineRe = new RegExp(longLineRePrefix + lineLength + longLineRePostfix);
      const longHeadingLineRe = new RegExp(longLineRePrefix + headingLineLength + longLineRePostfix);
      const longCodeLineRe = new RegExp(longLineRePrefix + codeLineLength + longLineRePostfix);
      const codeBlocks = params.config.code_blocks;
      const includeCodeBlocks = codeBlocks === void 0 ? true : !!codeBlocks;
      const tables = params.config.tables;
      const includeTables = tables === void 0 ? true : !!tables;
      let headings = params.config.headings;
      if (headings === void 0) {
        headings = params.config.headers;
      }
      const includeHeadings = headings === void 0 ? true : !!headings;
      const headingLineNumbers = [];
      forEachHeading(params, (heading) => {
        headingLineNumbers.push(heading.lineNumber);
      });
      const linkOnlyLineNumbers = [];
      filterTokens(params, "inline", (token) => {
        let childTokenTypes = "";
        token.children.forEach((child) => {
          if (child.type !== "text" || child.content !== "") {
            childTokenTypes += tokenTypeMap[child.type] || "x";
          }
        });
        if (linkOrImageOnlyLineRe.test(childTokenTypes)) {
          linkOnlyLineNumbers.push(token.lineNumber);
        }
      });
      forEachLine(lineMetadata(), (line, lineIndex, inCode, onFence, inTable) => {
        const lineNumber = lineIndex + 1;
        const isHeading = includesSorted(headingLineNumbers, lineNumber);
        const length = inCode ? codeLineLength : isHeading ? headingLineLength : lineLength;
        const lengthRe = inCode ? longCodeLineRe : isHeading ? longHeadingLineRe : longLineRe;
        if ((includeCodeBlocks || !inCode) && (includeTables || !inTable) && (includeHeadings || !isHeading) && (strict || !(stern && sternModeRe.test(line)) && !includesSorted(linkOnlyLineNumbers, lineNumber) && !labelRe.test(line)) && lengthRe.test(line)) {
          addErrorDetailIf(onError, lineNumber, length, line.length, null, null, [length + 1, line.length - length]);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md014.js
var require_md014 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens} = require_helpers2();
  var dollarCommandRe = /^(\s*)(\$\s+)/;
  module2.exports = {
    names: ["MD014", "commands-show-output"],
    description: "Dollar signs used before commands without showing output",
    tags: ["code"],
    function: function MD014(params, onError) {
      ["code_block", "fence"].forEach((type) => {
        filterTokens(params, type, (token) => {
          const margin = token.type === "fence" ? 1 : 0;
          const dollarInstances = [];
          let allDollars = true;
          for (let i = token.map[0] + margin; i < token.map[1] - margin; i++) {
            const line = params.lines[i];
            const lineTrim = line.trim();
            if (lineTrim) {
              const match = dollarCommandRe.exec(line);
              if (match) {
                const column = match[1].length + 1;
                const length = match[2].length;
                dollarInstances.push([i, lineTrim, column, length]);
              } else {
                allDollars = false;
              }
            }
          }
          if (allDollars) {
            dollarInstances.forEach((instance) => {
              const [i, lineTrim, column, length] = instance;
              addErrorContext(onError, i + 1, lineTrim, null, null, [column, length], {
                editColumn: column,
                deleteCount: length
              });
            });
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md018.js
var require_md018 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, forEachLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  module2.exports = {
    names: ["MD018", "no-missing-space-atx"],
    description: "No space after hash on atx style heading",
    tags: ["headings", "headers", "atx", "spaces"],
    function: function MD018(params, onError) {
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        if (!inCode && /^#+[^# \t]/.test(line) && !/#\s*$/.test(line) && !line.startsWith("#\uFE0F\u20E3")) {
          const hashCount = /^#+/.exec(line)[0].length;
          addErrorContext(onError, lineIndex + 1, line.trim(), null, null, [1, hashCount + 1], {
            editColumn: hashCount + 1,
            insertText: " "
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md019.js
var require_md019 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens, headingStyleFor} = require_helpers2();
  module2.exports = {
    names: ["MD019", "no-multiple-space-atx"],
    description: "Multiple spaces after hash on atx style heading",
    tags: ["headings", "headers", "atx", "spaces"],
    function: function MD019(params, onError) {
      filterTokens(params, "heading_open", (token) => {
        if (headingStyleFor(token) === "atx") {
          const {line, lineNumber} = token;
          const match = /^(#+)([ \t]{2,})(?:\S)/.exec(line);
          if (match) {
            const [
              ,
              {length: hashLength},
              {length: spacesLength}
            ] = match;
            addErrorContext(onError, lineNumber, line.trim(), null, null, [1, hashLength + spacesLength + 1], {
              editColumn: hashLength + 1,
              deleteCount: spacesLength - 1
            });
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md020.js
var require_md020 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, forEachLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  module2.exports = {
    names: ["MD020", "no-missing-space-closed-atx"],
    description: "No space inside hashes on closed atx style heading",
    tags: ["headings", "headers", "atx_closed", "spaces"],
    function: function MD020(params, onError) {
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        if (!inCode) {
          const match = /^(#+)([ \t]*)([^#]*?[^#\\])([ \t]*)((?:\\#)?)(#+)(\s*)$/.exec(line);
          if (match) {
            const [
              ,
              leftHash,
              {length: leftSpaceLength},
              content,
              {length: rightSpaceLength},
              rightEscape,
              rightHash,
              {length: trailSpaceLength}
            ] = match;
            const leftHashLength = leftHash.length;
            const rightHashLength = rightHash.length;
            const left = !leftSpaceLength;
            const right = !rightSpaceLength || rightEscape;
            const rightEscapeReplacement = rightEscape ? `${rightEscape} ` : "";
            if (left || right) {
              const range = left ? [
                1,
                leftHashLength + 1
              ] : [
                line.length - trailSpaceLength - rightHashLength,
                rightHashLength + 1
              ];
              addErrorContext(onError, lineIndex + 1, line.trim(), left, right, range, {
                editColumn: 1,
                deleteCount: line.length,
                insertText: `${leftHash} ${content} ${rightEscapeReplacement}${rightHash}`
              });
            }
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md021.js
var require_md021 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens, headingStyleFor} = require_helpers2();
  module2.exports = {
    names: ["MD021", "no-multiple-space-closed-atx"],
    description: "Multiple spaces inside hashes on closed atx style heading",
    tags: ["headings", "headers", "atx_closed", "spaces"],
    function: function MD021(params, onError) {
      filterTokens(params, "heading_open", (token) => {
        if (headingStyleFor(token) === "atx_closed") {
          const {line, lineNumber} = token;
          const match = /^(#+)([ \t]+)([^#]+?)([ \t]+)(#+)(\s*)$/.exec(line);
          if (match) {
            const [
              ,
              leftHash,
              {length: leftSpaceLength},
              content,
              {length: rightSpaceLength},
              rightHash,
              {length: trailSpaceLength}
            ] = match;
            const left = leftSpaceLength > 1;
            const right = rightSpaceLength > 1;
            if (left || right) {
              const length = line.length;
              const leftHashLength = leftHash.length;
              const rightHashLength = rightHash.length;
              const range = left ? [
                1,
                leftHashLength + leftSpaceLength + 1
              ] : [
                length - trailSpaceLength - rightHashLength - rightSpaceLength,
                rightSpaceLength + rightHashLength + 1
              ];
              addErrorContext(onError, lineNumber, line.trim(), left, right, range, {
                editColumn: 1,
                deleteCount: length,
                insertText: `${leftHash} ${content} ${rightHash}`
              });
            }
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md022.js
var require_md022 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, filterTokens, isBlankLine} = require_helpers2();
  module2.exports = {
    names: ["MD022", "blanks-around-headings", "blanks-around-headers"],
    description: "Headings should be surrounded by blank lines",
    tags: ["headings", "headers", "blank_lines"],
    function: function MD022(params, onError) {
      let linesAbove = params.config.lines_above;
      linesAbove = Number(linesAbove === void 0 ? 1 : linesAbove);
      let linesBelow = params.config.lines_below;
      linesBelow = Number(linesBelow === void 0 ? 1 : linesBelow);
      const {lines} = params;
      filterTokens(params, "heading_open", (token) => {
        const [topIndex, nextIndex] = token.map;
        let actualAbove = 0;
        for (let i = 0; i < linesAbove; i++) {
          if (isBlankLine(lines[topIndex - i - 1])) {
            actualAbove++;
          }
        }
        addErrorDetailIf(onError, topIndex + 1, linesAbove, actualAbove, "Above", lines[topIndex].trim(), null, {
          insertText: "".padEnd(linesAbove - actualAbove, "\n")
        });
        let actualBelow = 0;
        for (let i = 0; i < linesBelow; i++) {
          if (isBlankLine(lines[nextIndex + i])) {
            actualBelow++;
          }
        }
        addErrorDetailIf(onError, topIndex + 1, linesBelow, actualBelow, "Below", lines[topIndex].trim(), null, {
          lineNumber: nextIndex + 1,
          insertText: "".padEnd(linesBelow - actualBelow, "\n")
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md023.js
var require_md023 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens} = require_helpers2();
  var spaceBeforeHeadingRe = /^((?:\s+)|(?:[>\s]+\s\s))[^>\s]/;
  module2.exports = {
    names: ["MD023", "heading-start-left", "header-start-left"],
    description: "Headings must start at the beginning of the line",
    tags: ["headings", "headers", "spaces"],
    function: function MD023(params, onError) {
      filterTokens(params, "heading_open", function forToken(token) {
        const {lineNumber, line} = token;
        const match = line.match(spaceBeforeHeadingRe);
        if (match) {
          const [prefixAndFirstChar, prefix] = match;
          let deleteCount = prefix.length;
          const prefixLengthNoSpace = prefix.trimEnd().length;
          if (prefixLengthNoSpace) {
            deleteCount -= prefixLengthNoSpace - 1;
          }
          addErrorContext(onError, lineNumber, line, null, null, [1, prefixAndFirstChar.length], {
            editColumn: prefixLengthNoSpace + 1,
            deleteCount
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md024.js
var require_md024 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, forEachHeading} = require_helpers2();
  module2.exports = {
    names: ["MD024", "no-duplicate-heading", "no-duplicate-header"],
    description: "Multiple headings with the same content",
    tags: ["headings", "headers"],
    function: function MD024(params, onError) {
      const siblingsOnly = !!params.config.siblings_only || !!params.config.allow_different_nesting || false;
      const knownContents = [null, []];
      let lastLevel = 1;
      let knownContent = knownContents[lastLevel];
      forEachHeading(params, (heading, content) => {
        if (siblingsOnly) {
          const newLevel = heading.tag.slice(1);
          while (lastLevel < newLevel) {
            lastLevel++;
            knownContents[lastLevel] = [];
          }
          while (lastLevel > newLevel) {
            knownContents[lastLevel] = [];
            lastLevel--;
          }
          knownContent = knownContents[newLevel];
        }
        if (knownContent.includes(content)) {
          addErrorContext(onError, heading.lineNumber, heading.line.trim());
        } else {
          knownContent.push(content);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md025.js
var require_md025 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens, frontMatterHasTitle} = require_helpers2();
  module2.exports = {
    names: ["MD025", "single-title", "single-h1"],
    description: "Multiple top-level headings in the same document",
    tags: ["headings", "headers"],
    function: function MD025(params, onError) {
      const level = Number(params.config.level || 1);
      const tag = "h" + level;
      const foundFrontMatterTitle = frontMatterHasTitle(params.frontMatterLines, params.config.front_matter_title);
      let hasTopLevelHeading = false;
      filterTokens(params, "heading_open", function forToken(token) {
        if (token.tag === tag) {
          if (hasTopLevelHeading || foundFrontMatterTitle) {
            addErrorContext(onError, token.lineNumber, token.line.trim());
          } else if (token.lineNumber === 1) {
            hasTopLevelHeading = true;
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md026.js
var require_md026 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, allPunctuationNoQuestion, escapeForRegExp, forEachHeading} = require_helpers2();
  var endOfLineHtmlEntityRe = /&#?[0-9a-zA-Z]+;$/;
  module2.exports = {
    names: ["MD026", "no-trailing-punctuation"],
    description: "Trailing punctuation in heading",
    tags: ["headings", "headers"],
    function: function MD026(params, onError) {
      let punctuation = params.config.punctuation;
      punctuation = String(punctuation === void 0 ? allPunctuationNoQuestion : punctuation);
      const trailingPunctuationRe = new RegExp("\\s*[" + escapeForRegExp(punctuation) + "]+$");
      forEachHeading(params, (heading) => {
        const {line, lineNumber} = heading;
        const trimmedLine = line.replace(/[\s#]*$/, "");
        const match = trailingPunctuationRe.exec(trimmedLine);
        if (match && !endOfLineHtmlEntityRe.test(trimmedLine)) {
          const fullMatch = match[0];
          const column = match.index + 1;
          const length = fullMatch.length;
          addError(onError, lineNumber, `Punctuation: '${fullMatch}'`, null, [column, length], {
            editColumn: column,
            deleteCount: length
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md027.js
var require_md027 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, newLineRe} = require_helpers2();
  var spaceAfterBlockQuoteRe = /^((?:\s*>)+)(\s{2,})\S/;
  module2.exports = {
    names: ["MD027", "no-multiple-space-blockquote"],
    description: "Multiple spaces after blockquote symbol",
    tags: ["blockquote", "whitespace", "indentation"],
    function: function MD027(params, onError) {
      let blockquoteNesting = 0;
      let listItemNesting = 0;
      params.tokens.forEach((token) => {
        const {content, lineNumber, type} = token;
        if (type === "blockquote_open") {
          blockquoteNesting++;
        } else if (type === "blockquote_close") {
          blockquoteNesting--;
        } else if (type === "list_item_open") {
          listItemNesting++;
        } else if (type === "list_item_close") {
          listItemNesting--;
        } else if (type === "inline" && blockquoteNesting) {
          const lineCount = content.split(newLineRe).length;
          for (let i = 0; i < lineCount; i++) {
            const line = params.lines[lineNumber + i - 1];
            const match = line.match(spaceAfterBlockQuoteRe);
            if (match) {
              const [
                fullMatch,
                {length: blockquoteLength},
                {length: spaceLength}
              ] = match;
              if (!listItemNesting || fullMatch[fullMatch.length - 1] === ">") {
                addErrorContext(onError, lineNumber + i, line, null, null, [1, fullMatch.length], {
                  editColumn: blockquoteLength + 1,
                  deleteCount: spaceLength - 1
                });
              }
            }
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md028.js
var require_md028 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError} = require_helpers2();
  module2.exports = {
    names: ["MD028", "no-blanks-blockquote"],
    description: "Blank line inside blockquote",
    tags: ["blockquote", "whitespace"],
    function: function MD028(params, onError) {
      let prevToken = {};
      let prevLineNumber = null;
      params.tokens.forEach(function forToken(token) {
        if (token.type === "blockquote_open" && prevToken.type === "blockquote_close") {
          for (let lineNumber = prevLineNumber; lineNumber < token.lineNumber; lineNumber++) {
            addError(onError, lineNumber);
          }
        }
        prevToken = token;
        if (token.type === "blockquote_open") {
          prevLineNumber = token.map[1] + 1;
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md029.js
var require_md029 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    addErrorDetailIf,
    listItemMarkerRe,
    orderedListItemMarkerRe,
    rangeFromRegExp
  } = require_helpers2();
  var {flattenedLists} = require_cache();
  var listStyleExamples = {
    one: "1/1/1",
    ordered: "1/2/3",
    zero: "0/0/0"
  };
  module2.exports = {
    names: ["MD029", "ol-prefix"],
    description: "Ordered list item prefix",
    tags: ["ol"],
    function: function MD029(params, onError) {
      const style = String(params.config.style || "one_or_ordered");
      flattenedLists().filter((list) => !list.unordered).forEach((list) => {
        const {items} = list;
        let current = 1;
        let incrementing = false;
        if (items.length >= 2) {
          const first = orderedListItemMarkerRe.exec(items[0].line);
          const second = orderedListItemMarkerRe.exec(items[1].line);
          if (first && second) {
            const [, firstNumber] = first;
            const [, secondNumber] = second;
            if (secondNumber !== "1" || firstNumber === "0") {
              incrementing = true;
              if (firstNumber === "0") {
                current = 0;
              }
            }
          }
        }
        let listStyle = style;
        if (listStyle === "one_or_ordered") {
          listStyle = incrementing ? "ordered" : "one";
        }
        if (listStyle === "zero") {
          current = 0;
        } else if (listStyle === "one") {
          current = 1;
        }
        items.forEach((item) => {
          const match = orderedListItemMarkerRe.exec(item.line);
          if (match) {
            addErrorDetailIf(onError, item.lineNumber, String(current), match[1], "Style: " + listStyleExamples[listStyle], null, rangeFromRegExp(item.line, listItemMarkerRe));
            if (listStyle === "ordered") {
              current++;
            }
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md030.js
var require_md030 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf} = require_helpers2();
  var {flattenedLists} = require_cache();
  module2.exports = {
    names: ["MD030", "list-marker-space"],
    description: "Spaces after list markers",
    tags: ["ol", "ul", "whitespace"],
    function: function MD030(params, onError) {
      const ulSingle = Number(params.config.ul_single || 1);
      const olSingle = Number(params.config.ol_single || 1);
      const ulMulti = Number(params.config.ul_multi || 1);
      const olMulti = Number(params.config.ol_multi || 1);
      flattenedLists().forEach((list) => {
        const lineCount = list.lastLineIndex - list.open.map[0];
        const allSingle = lineCount === list.items.length;
        const expectedSpaces = list.unordered ? allSingle ? ulSingle : ulMulti : allSingle ? olSingle : olMulti;
        list.items.forEach((item) => {
          const {line, lineNumber} = item;
          const match = /^[\s>]*\S+(\s*)/.exec(line);
          const [{length: matchLength}, {length: actualSpaces}] = match;
          if (matchLength < line.length) {
            let fixInfo = null;
            if (expectedSpaces !== actualSpaces) {
              fixInfo = {
                editColumn: matchLength - actualSpaces + 1,
                deleteCount: actualSpaces,
                insertText: "".padEnd(expectedSpaces)
              };
            }
            addErrorDetailIf(onError, lineNumber, expectedSpaces, actualSpaces, null, null, [1, matchLength], fixInfo);
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md031.js
var require_md031 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, forEachLine, isBlankLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  var codeFencePrefixRe = /^(.*?)\s*[`~]/;
  module2.exports = {
    names: ["MD031", "blanks-around-fences"],
    description: "Fenced code blocks should be surrounded by blank lines",
    tags: ["code", "blank_lines"],
    function: function MD031(params, onError) {
      const listItems = params.config.list_items;
      const includeListItems = listItems === void 0 ? true : !!listItems;
      const {lines} = params;
      forEachLine(lineMetadata(), (line, i, inCode, onFence, inTable, inItem) => {
        const onTopFence = onFence > 0;
        const onBottomFence = onFence < 0;
        if ((includeListItems || !inItem) && (onTopFence && !isBlankLine(lines[i - 1]) || onBottomFence && !isBlankLine(lines[i + 1]))) {
          const [, prefix] = line.match(codeFencePrefixRe) || [];
          const fixInfo = prefix === void 0 ? null : {
            lineNumber: i + (onTopFence ? 1 : 2),
            insertText: `${prefix}
`
          };
          addErrorContext(onError, i + 1, lines[i].trim(), null, null, null, fixInfo);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md032.js
var require_md032 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, isBlankLine} = require_helpers2();
  var {flattenedLists} = require_cache();
  var quotePrefixRe = /^[>\s]*/;
  module2.exports = {
    names: ["MD032", "blanks-around-lists"],
    description: "Lists should be surrounded by blank lines",
    tags: ["bullet", "ul", "ol", "blank_lines"],
    function: function MD032(params, onError) {
      const {lines} = params;
      flattenedLists().filter((list) => !list.nesting).forEach((list) => {
        const firstIndex = list.open.map[0];
        if (!isBlankLine(lines[firstIndex - 1])) {
          const line = lines[firstIndex];
          const quotePrefix = line.match(quotePrefixRe)[0].trimEnd();
          addErrorContext(onError, firstIndex + 1, line.trim(), null, null, null, {
            insertText: `${quotePrefix}
`
          });
        }
        const lastIndex = list.lastLineIndex - 1;
        if (!isBlankLine(lines[lastIndex + 1])) {
          const line = lines[lastIndex];
          const quotePrefix = line.match(quotePrefixRe)[0].trimEnd();
          addErrorContext(onError, lastIndex + 1, line.trim(), null, null, null, {
            lineNumber: lastIndex + 2,
            insertText: `${quotePrefix}
`
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md033.js
var require_md033 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, forEachLine, unescapeMarkdown} = require_helpers2();
  var {lineMetadata} = require_cache();
  var htmlElementRe = /<(([A-Za-z][A-Za-z0-9-]*)(?:\s[^>]*)?)\/?>/g;
  var linkDestinationRe = /]\(\s*$/;
  var inlineCodeRe = /^[^`]*(`+[^`]+`+[^`]+)*`+[^`]*$/;
  var emailAddressRe = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  module2.exports = {
    names: ["MD033", "no-inline-html"],
    description: "Inline HTML",
    tags: ["html"],
    function: function MD033(params, onError) {
      let allowedElements = params.config.allowed_elements;
      allowedElements = Array.isArray(allowedElements) ? allowedElements : [];
      allowedElements = allowedElements.map((element) => element.toLowerCase());
      forEachLine(lineMetadata(), (line, lineIndex, inCode) => {
        let match = null;
        while (!inCode && (match = htmlElementRe.exec(line)) !== null) {
          const [tag, content, element] = match;
          if (!allowedElements.includes(element.toLowerCase()) && !tag.endsWith("\\>") && !emailAddressRe.test(content)) {
            const prefix = line.substring(0, match.index);
            if (!linkDestinationRe.test(prefix) && !inlineCodeRe.test(prefix)) {
              const unescaped = unescapeMarkdown(prefix + "<", "_");
              if (!unescaped.endsWith("_") && (unescaped + "`").match(/`/g).length % 2) {
                addError(onError, lineIndex + 1, "Element: " + element, null, [match.index + 1, tag.length]);
              }
            }
          }
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md034.js
var require_md034 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, bareUrlRe, filterTokens} = require_helpers2();
  module2.exports = {
    names: ["MD034", "no-bare-urls"],
    description: "Bare URL used",
    tags: ["links", "url"],
    function: function MD034(params, onError) {
      filterTokens(params, "inline", (token) => {
        let inLink = false;
        token.children.forEach((child) => {
          const {content, line, lineNumber, type} = child;
          let match = null;
          if (type === "link_open") {
            inLink = true;
          } else if (type === "link_close") {
            inLink = false;
          } else if (type === "text" && !inLink) {
            while ((match = bareUrlRe.exec(content)) !== null) {
              const [bareUrl] = match;
              const matchIndex = match.index;
              const bareUrlLength = bareUrl.length;
              const leftChar = content[matchIndex - 1];
              const rightChar = content[matchIndex + bareUrlLength];
              if (!(leftChar === "[" && rightChar === "]") && !(leftChar === '"' && rightChar === '"') && !(leftChar === "'" && rightChar === "'")) {
                const index = line.indexOf(content);
                const range = index === -1 ? null : [
                  index + matchIndex + 1,
                  bareUrlLength
                ];
                const fixInfo = range ? {
                  editColumn: range[0],
                  deleteCount: range[1],
                  insertText: `<${bareUrl}>`
                } : null;
                addErrorContext(onError, lineNumber, bareUrl, null, null, range, fixInfo);
              }
            }
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md035.js
var require_md035 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, filterTokens} = require_helpers2();
  module2.exports = {
    names: ["MD035", "hr-style"],
    description: "Horizontal rule style",
    tags: ["hr"],
    function: function MD035(params, onError) {
      let style = String(params.config.style || "consistent");
      filterTokens(params, "hr", function forToken(token) {
        const lineTrim = token.line.trim();
        if (style === "consistent") {
          style = lineTrim;
        }
        addErrorDetailIf(onError, token.lineNumber, style, lineTrim);
      });
    }
  };
});

// node_modules/markdownlint/lib/md036.js
var require_md036 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, allPunctuation} = require_helpers2();
  module2.exports = {
    names: ["MD036", "no-emphasis-as-heading", "no-emphasis-as-header"],
    description: "Emphasis used instead of a heading",
    tags: ["headings", "headers", "emphasis"],
    function: function MD036(params, onError) {
      let punctuation = params.config.punctuation;
      punctuation = String(punctuation === void 0 ? allPunctuation : punctuation);
      const re = new RegExp("[" + punctuation + "]$");
      function base(token) {
        if (token.type === "paragraph_open") {
          return function inParagraph(t) {
            const children = t.children.filter(function notEmptyText(child) {
              return child.type !== "text" || child.content !== "";
            });
            if (children.length === 3 && (children[0].type === "strong_open" || children[0].type === "em_open") && children[1].type === "text" && !re.test(children[1].content)) {
              addErrorContext(onError, t.lineNumber, children[1].content);
            }
            return base;
          };
        } else if (token.type === "blockquote_open") {
          return function inBlockquote(t) {
            if (t.type !== "blockquote_close") {
              return inBlockquote;
            }
            return base;
          };
        } else if (token.type === "list_item_open") {
          return function inListItem(t) {
            if (t.type !== "list_item_close") {
              return inListItem;
            }
            return base;
          };
        }
        return base;
      }
      let state = base;
      params.tokens.forEach(function forToken(token) {
        state = state(token);
      });
    }
  };
});

// node_modules/markdownlint/lib/md037.js
var require_md037 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, emphasisMarkersInContent, forEachLine, isBlankLine} = require_helpers2();
  var {lineMetadata} = require_cache();
  var emphasisRe = /(^|[^\\]|\\\\)(?:(\*\*?\*?)|(__?_?))/g;
  var asteriskListItemMarkerRe = /^([\s>]*)\*(\s+)/;
  var leftSpaceRe = /^\s+/;
  var rightSpaceRe = /\s+$/;
  var tablePipeRe = /\|/;
  module2.exports = {
    names: ["MD037", "no-space-in-emphasis"],
    description: "Spaces inside emphasis markers",
    tags: ["whitespace", "emphasis"],
    function: function MD037(params, onError) {
      let effectiveEmphasisLength, emphasisIndex, emphasisKind, emphasisLength, pendingError = null;
      function resetRunTracking() {
        emphasisIndex = -1;
        emphasisLength = 0;
        emphasisKind = "";
        effectiveEmphasisLength = 0;
        pendingError = null;
      }
      function handleRunEnd(line, lineIndex, contextLength, match, matchIndex, inTable) {
        let content = line.substring(emphasisIndex, matchIndex);
        if (!emphasisLength) {
          content = content.trimStart();
        }
        if (!match) {
          content = content.trimEnd();
        }
        const leftSpace = leftSpaceRe.test(content);
        const rightSpace = rightSpaceRe.test(content);
        if ((leftSpace || rightSpace) && (!inTable || !tablePipeRe.test(content))) {
          const contextStart = emphasisIndex - emphasisLength;
          const contextEnd = matchIndex + contextLength;
          const context = line.substring(contextStart, contextEnd);
          const column = contextStart + 1;
          const length = contextEnd - contextStart;
          const leftMarker = line.substring(contextStart, emphasisIndex);
          const rightMarker = match ? match[2] || match[3] : "";
          const fixedText = `${leftMarker}${content.trim()}${rightMarker}`;
          return [
            onError,
            lineIndex + 1,
            context,
            leftSpace,
            rightSpace,
            [column, length],
            {
              editColumn: column,
              deleteCount: length,
              insertText: fixedText
            }
          ];
        }
        return null;
      }
      const ignoreMarkersByLine = emphasisMarkersInContent(params);
      resetRunTracking();
      forEachLine(lineMetadata(), (line, lineIndex, inCode, onFence, inTable, inItem, onBreak, inMath) => {
        const onItemStart = inItem === 1;
        if (inCode || inTable || onBreak || onItemStart || isBlankLine(line)) {
          resetRunTracking();
        }
        if (inCode || onBreak || inMath) {
          return;
        }
        if (onItemStart) {
          line = line.replace(asteriskListItemMarkerRe, "$1 $2");
        }
        let match = null;
        while (match = emphasisRe.exec(line)) {
          const ignoreMarkersForLine = ignoreMarkersByLine[lineIndex] || [];
          const matchIndex = match.index + match[1].length;
          if (ignoreMarkersForLine.includes(matchIndex)) {
            continue;
          }
          const matchLength = match[0].length - match[1].length;
          const matchKind = (match[2] || match[3])[0];
          if (emphasisIndex === -1) {
            emphasisIndex = matchIndex + matchLength;
            emphasisLength = matchLength;
            emphasisKind = matchKind;
            effectiveEmphasisLength = matchLength;
          } else if (matchKind === emphasisKind) {
            if (matchLength === effectiveEmphasisLength) {
              if (pendingError) {
                addErrorContext(...pendingError);
                pendingError = null;
              }
              const error = handleRunEnd(line, lineIndex, effectiveEmphasisLength, match, matchIndex, inTable);
              if (error) {
                addErrorContext(...error);
              }
              resetRunTracking();
            } else if (matchLength === 3) {
              effectiveEmphasisLength = matchLength - effectiveEmphasisLength;
            } else if (effectiveEmphasisLength === 3) {
              effectiveEmphasisLength -= matchLength;
            } else {
              effectiveEmphasisLength += matchLength;
            }
            if (emphasisRe.lastIndex > 1) {
              emphasisRe.lastIndex--;
            }
          } else if (emphasisRe.lastIndex > 1) {
            emphasisRe.lastIndex--;
          }
        }
        if (emphasisIndex !== -1) {
          pendingError = pendingError || handleRunEnd(line, lineIndex, 0, null, line.length, inTable);
          emphasisIndex = 0;
          emphasisLength = 0;
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md038.js
var require_md038 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens, forEachInlineCodeSpan, newLineRe} = require_helpers2();
  var leftSpaceRe = /^\s([^`]|$)/;
  var rightSpaceRe = /[^`]\s$/;
  var singleLeftRightSpaceRe = /^\s(?:\S.*\S|\S)\s$/;
  module2.exports = {
    names: ["MD038", "no-space-in-code"],
    description: "Spaces inside code span elements",
    tags: ["whitespace", "code"],
    function: function MD038(params, onError) {
      filterTokens(params, "inline", (token) => {
        if (token.children.some((child) => child.type === "code_inline")) {
          const tokenLines = params.lines.slice(token.map[0], token.map[1]);
          forEachInlineCodeSpan(tokenLines.join("\n"), (code, lineIndex, columnIndex, tickCount) => {
            let rangeIndex = columnIndex - tickCount;
            let rangeLength = code.length + 2 * tickCount;
            let rangeLineOffset = 0;
            let fixIndex = columnIndex;
            let fixLength = code.length;
            const codeLines = code.split(newLineRe);
            const left = leftSpaceRe.test(code);
            const right = !left && rightSpaceRe.test(code);
            if (right && codeLines.length > 1) {
              rangeIndex = 0;
              rangeLineOffset = codeLines.length - 1;
              fixIndex = 0;
            }
            const allowed = singleLeftRightSpaceRe.test(code);
            if ((left || right) && !allowed) {
              const codeLinesRange = codeLines[rangeLineOffset];
              if (codeLines.length > 1) {
                rangeLength = codeLinesRange.length + tickCount;
                fixLength = codeLinesRange.length;
              }
              const context = tokenLines[lineIndex + rangeLineOffset].substring(rangeIndex, rangeIndex + rangeLength);
              const codeLinesRangeTrim = codeLinesRange.trim();
              const fixText = (codeLinesRangeTrim.startsWith("`") ? " " : "") + codeLinesRangeTrim + (codeLinesRangeTrim.endsWith("`") ? " " : "");
              addErrorContext(onError, token.lineNumber + lineIndex + rangeLineOffset, context, left, right, [rangeIndex + 1, rangeLength], {
                editColumn: fixIndex + 1,
                deleteCount: fixLength,
                insertText: fixText
              });
            }
          });
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md039.js
var require_md039 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens} = require_helpers2();
  var spaceInLinkRe = /\[(?:\s+(?:[^\]]*?)\s*|(?:[^\]]*?)\s+)](?=\(\S*\))/;
  module2.exports = {
    names: ["MD039", "no-space-in-links"],
    description: "Spaces inside link text",
    tags: ["whitespace", "links"],
    function: function MD039(params, onError) {
      filterTokens(params, "inline", (token) => {
        const {children} = token;
        let {lineNumber} = token;
        let inLink = false;
        let linkText = "";
        let lineIndex = 0;
        children.forEach((child) => {
          const {content, type} = child;
          if (type === "link_open") {
            inLink = true;
            linkText = "";
          } else if (type === "link_close") {
            inLink = false;
            const left = linkText.trimStart().length !== linkText.length;
            const right = linkText.trimEnd().length !== linkText.length;
            if (left || right) {
              const line = params.lines[lineNumber - 1];
              let range = null;
              let fixInfo = null;
              const match = line.slice(lineIndex).match(spaceInLinkRe);
              if (match) {
                const column = match.index + lineIndex + 1;
                const length = match[0].length;
                range = [column, length];
                fixInfo = {
                  editColumn: column + 1,
                  deleteCount: length - 2,
                  insertText: linkText.trim()
                };
                lineIndex = column + length - 1;
              }
              addErrorContext(onError, lineNumber, `[${linkText}]`, left, right, range, fixInfo);
            }
          } else if (type === "softbreak" || type === "hardbreak") {
            lineNumber++;
            lineIndex = 0;
          } else if (inLink) {
            linkText += content;
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md040.js
var require_md040 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens} = require_helpers2();
  module2.exports = {
    names: ["MD040", "fenced-code-language"],
    description: "Fenced code blocks should have a language specified",
    tags: ["code", "language"],
    function: function MD040(params, onError) {
      filterTokens(params, "fence", function forToken(token) {
        if (!token.info.trim()) {
          addErrorContext(onError, token.lineNumber, token.line);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md041.js
var require_md041 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, frontMatterHasTitle} = require_helpers2();
  module2.exports = {
    names: ["MD041", "first-line-heading", "first-line-h1"],
    description: "First line in a file should be a top-level heading",
    tags: ["headings", "headers"],
    function: function MD041(params, onError) {
      const level = Number(params.config.level || 1);
      const tag = "h" + level;
      const foundFrontMatterTitle = frontMatterHasTitle(params.frontMatterLines, params.config.front_matter_title);
      if (!foundFrontMatterTitle) {
        const htmlHeadingRe = new RegExp(`^<h${level}[ />]`, "i");
        params.tokens.every((token) => {
          let isError = false;
          if (token.type === "html_block") {
            if (token.content.startsWith("<!--")) {
              return true;
            } else if (!htmlHeadingRe.test(token.content)) {
              isError = true;
            }
          } else if (token.type !== "heading_open" || token.tag !== tag) {
            isError = true;
          }
          if (isError) {
            addErrorContext(onError, token.lineNumber, token.line);
          }
          return false;
        });
      }
    }
  };
});

// node_modules/markdownlint/lib/md042.js
var require_md042 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, filterTokens, rangeFromRegExp} = require_helpers2();
  var emptyLinkRe = /\[[^\]]*](?:\((?:#?|(?:<>))\))/;
  module2.exports = {
    names: ["MD042", "no-empty-links"],
    description: "No empty links",
    tags: ["links"],
    function: function MD042(params, onError) {
      filterTokens(params, "inline", function forToken(token) {
        let inLink = false;
        let linkText = "";
        let emptyLink = false;
        token.children.forEach(function forChild(child) {
          if (child.type === "link_open") {
            inLink = true;
            linkText = "";
            child.attrs.forEach(function forAttr(attr) {
              if (attr[0] === "href" && (!attr[1] || attr[1] === "#")) {
                emptyLink = true;
              }
            });
          } else if (child.type === "link_close") {
            inLink = false;
            if (emptyLink) {
              addErrorContext(onError, child.lineNumber, "[" + linkText + "]()", null, null, rangeFromRegExp(child.line, emptyLinkRe));
              emptyLink = false;
            }
          } else if (inLink) {
            linkText += child.content;
          }
        });
      });
    }
  };
});

// node_modules/markdownlint/lib/md043.js
var require_md043 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorContext, addErrorDetailIf, forEachHeading} = require_helpers2();
  module2.exports = {
    names: ["MD043", "required-headings", "required-headers"],
    description: "Required heading structure",
    tags: ["headings", "headers"],
    function: function MD043(params, onError) {
      const requiredHeadings = params.config.headings || params.config.headers;
      if (Array.isArray(requiredHeadings)) {
        const levels = {};
        [1, 2, 3, 4, 5, 6].forEach((level) => {
          levels["h" + level] = "######".substr(-level);
        });
        let i = 0;
        let matchAny = false;
        let hasError = false;
        let anyHeadings = false;
        const getExpected = () => requiredHeadings[i++] || "[None]";
        forEachHeading(params, (heading, content) => {
          if (!hasError) {
            anyHeadings = true;
            const actual = levels[heading.tag] + " " + content;
            const expected = getExpected();
            if (expected === "*") {
              matchAny = true;
              getExpected();
            } else if (expected === "+") {
              matchAny = true;
            } else if (expected.toLowerCase() === actual.toLowerCase()) {
              matchAny = false;
            } else if (matchAny) {
              i--;
            } else {
              addErrorDetailIf(onError, heading.lineNumber, expected, actual);
              hasError = true;
            }
          }
        });
        if (!hasError && i < requiredHeadings.length && (anyHeadings || !requiredHeadings.every((heading) => heading === "*"))) {
          addErrorContext(onError, params.lines.length, requiredHeadings[i]);
        }
      }
    }
  };
});

// node_modules/markdownlint/lib/md044.js
var require_md044 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    addErrorDetailIf,
    bareUrlRe,
    escapeForRegExp,
    filterTokens,
    forEachInlineChild,
    newLineRe
  } = require_helpers2();
  var startNonWordRe = /^\W/;
  var endNonWordRe = /\W$/;
  module2.exports = {
    names: ["MD044", "proper-names"],
    description: "Proper names should have the correct capitalization",
    tags: ["spelling"],
    function: function MD044(params, onError) {
      let names = params.config.names;
      names = Array.isArray(names) ? names : [];
      const codeBlocks = params.config.code_blocks;
      const includeCodeBlocks = codeBlocks === void 0 ? true : !!codeBlocks;
      const autolinkText = new Set();
      filterTokens(params, "inline", (token) => {
        let inAutoLink = false;
        token.children.forEach((child) => {
          const {info, type} = child;
          if (type === "link_open" && info === "auto") {
            inAutoLink = true;
          } else if (type === "link_close") {
            inAutoLink = false;
          } else if (type === "text" && inAutoLink) {
            autolinkText.add(child);
          }
        });
      });
      names.forEach((name) => {
        const escapedName = escapeForRegExp(name);
        const startNamePattern = startNonWordRe.test(name) ? "" : "\\S*\\b";
        const endNamePattern = endNonWordRe.test(name) ? "" : "\\b\\S*";
        const namePattern = `(${startNamePattern})(${escapedName})(${endNamePattern})`;
        const anyNameRe = new RegExp(namePattern, "gi");
        function forToken(token) {
          if (!autolinkText.has(token)) {
            const fenceOffset = token.type === "fence" ? 1 : 0;
            token.content.split(newLineRe).forEach((line, index) => {
              let match = null;
              while ((match = anyNameRe.exec(line)) !== null) {
                const [fullMatch, leftMatch, nameMatch, rightMatch] = match;
                if (fullMatch.search(bareUrlRe) === -1) {
                  const wordMatch = fullMatch.replace(new RegExp(`^\\W{0,${leftMatch.length}}`), "").replace(new RegExp(`\\W{0,${rightMatch.length}}$`), "");
                  if (!names.includes(wordMatch)) {
                    const lineNumber = token.lineNumber + index + fenceOffset;
                    const fullLine = params.lines[lineNumber - 1];
                    const matchLength = wordMatch.length;
                    const matchIndex = fullLine.indexOf(wordMatch);
                    const range = matchIndex === -1 ? null : [matchIndex + 1, matchLength];
                    const fixInfo = matchIndex === -1 ? null : {
                      editColumn: matchIndex + 1,
                      deleteCount: matchLength,
                      insertText: name
                    };
                    addErrorDetailIf(onError, lineNumber, name, nameMatch, null, null, range, fixInfo);
                  }
                }
              }
            });
          }
        }
        forEachInlineChild(params, "text", forToken);
        if (includeCodeBlocks) {
          forEachInlineChild(params, "code_inline", forToken);
          filterTokens(params, "code_block", forToken);
          filterTokens(params, "fence", forToken);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md045.js
var require_md045 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, forEachInlineChild} = require_helpers2();
  module2.exports = {
    names: ["MD045", "no-alt-text"],
    description: "Images should have alternate text (alt text)",
    tags: ["accessibility", "images"],
    function: function MD045(params, onError) {
      forEachInlineChild(params, "image", function forToken(token) {
        if (token.content === "") {
          addError(onError, token.lineNumber);
        }
      });
    }
  };
});

// node_modules/markdownlint/lib/md046.js
var require_md046 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf} = require_helpers2();
  var tokenTypeToStyle = {
    fence: "fenced",
    code_block: "indented"
  };
  module2.exports = {
    names: ["MD046", "code-block-style"],
    description: "Code block style",
    tags: ["code"],
    function: function MD046(params, onError) {
      let expectedStyle = String(params.config.style || "consistent");
      params.tokens.filter((token) => token.type === "code_block" || token.type === "fence").forEach((token) => {
        const {lineNumber, type} = token;
        if (expectedStyle === "consistent") {
          expectedStyle = tokenTypeToStyle[type];
        }
        addErrorDetailIf(onError, lineNumber, expectedStyle, tokenTypeToStyle[type]);
      });
    }
  };
});

// node_modules/markdownlint/lib/md047.js
var require_md047 = __commonJS((exports2, module2) => {
  "use strict";
  var {addError, isBlankLine} = require_helpers2();
  module2.exports = {
    names: ["MD047", "single-trailing-newline"],
    description: "Files should end with a single newline character",
    tags: ["blank_lines"],
    function: function MD047(params, onError) {
      const lastLineNumber = params.lines.length;
      const lastLine = params.lines[lastLineNumber - 1];
      if (!isBlankLine(lastLine)) {
        addError(onError, lastLineNumber, null, null, [lastLine.length, 1], {
          insertText: "\n",
          editColumn: lastLine.length + 1
        });
      }
    }
  };
});

// node_modules/markdownlint/lib/md048.js
var require_md048 = __commonJS((exports2, module2) => {
  "use strict";
  var {addErrorDetailIf, fencedCodeBlockStyleFor} = require_helpers2();
  module2.exports = {
    names: ["MD048", "code-fence-style"],
    description: "Code fence style",
    tags: ["code"],
    function: function MD048(params, onError) {
      const style = String(params.config.style || "consistent");
      let expectedStyle = style;
      params.tokens.filter((token) => token.type === "fence").forEach((fenceToken) => {
        const {lineNumber, markup} = fenceToken;
        if (expectedStyle === "consistent") {
          expectedStyle = fencedCodeBlockStyleFor(markup);
        }
        addErrorDetailIf(onError, lineNumber, expectedStyle, fencedCodeBlockStyleFor(markup));
      });
    }
  };
});

// node_modules/markdownlint/lib/rules.js
var require_rules = __commonJS((exports2, module2) => {
  "use strict";
  var URL2 = require("url").URL;
  var packageJson = require_package();
  var homepage = packageJson.homepage;
  var version = packageJson.version;
  var rules = [
    require_md001(),
    require_md002(),
    require_md003(),
    require_md004(),
    require_md005(),
    require_md006(),
    require_md007(),
    require_md009(),
    require_md010(),
    require_md011(),
    require_md012(),
    require_md013(),
    require_md014(),
    require_md018(),
    require_md019(),
    require_md020(),
    require_md021(),
    require_md022(),
    require_md023(),
    require_md024(),
    require_md025(),
    require_md026(),
    require_md027(),
    require_md028(),
    require_md029(),
    require_md030(),
    require_md031(),
    require_md032(),
    require_md033(),
    require_md034(),
    require_md035(),
    require_md036(),
    require_md037(),
    require_md038(),
    require_md039(),
    require_md040(),
    require_md041(),
    require_md042(),
    require_md043(),
    require_md044(),
    require_md045(),
    require_md046(),
    require_md047(),
    require_md048()
  ];
  rules.forEach((rule) => {
    const name = rule.names[0].toLowerCase();
    rule["information"] = new URL2(`${homepage}/blob/v${version}/doc/Rules.md#${name}`);
  });
  module2.exports = rules;
});

// node_modules/markdownlint/lib/markdownlint.js
var require_markdownlint = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path2 = require("path");
  var {promisify} = require("util");
  var markdownIt = require_markdown_it();
  var rules = require_rules();
  var helpers = require_helpers2();
  var cache = require_cache();
  var dynamicRequire = typeof __non_webpack_require__ === "undefined" ? require : __non_webpack_require__;
  var deprecatedRuleNames = ["MD002", "MD006"];
  function validateRuleList(ruleList) {
    let result = null;
    if (ruleList.length === rules.length) {
      return result;
    }
    const allIds = {};
    ruleList.forEach(function forRule(rule, index) {
      const customIndex = index - rules.length;
      function newError(property) {
        return new Error("Property '" + property + "' of custom rule at index " + customIndex + " is incorrect.");
      }
      ["names", "tags"].forEach(function forProperty(property) {
        const value = rule[property];
        if (!result && (!value || !Array.isArray(value) || value.length === 0 || !value.every(helpers.isString) || value.some(helpers.isEmptyString))) {
          result = newError(property);
        }
      });
      [
        ["description", "string"],
        ["function", "function"]
      ].forEach(function forProperty(propertyInfo) {
        const property = propertyInfo[0];
        const value = rule[property];
        if (!result && (!value || typeof value !== propertyInfo[1])) {
          result = newError(property);
        }
      });
      if (!result && rule.information && Object.getPrototypeOf(rule.information) !== URL.prototype) {
        result = newError("information");
      }
      if (!result) {
        rule.names.forEach(function forName(name) {
          const nameUpper = name.toUpperCase();
          if (!result && allIds[nameUpper] !== void 0) {
            result = new Error("Name '" + name + "' of custom rule at index " + customIndex + " is already used as a name or tag.");
          }
          allIds[nameUpper] = true;
        });
        rule.tags.forEach(function forTag(tag) {
          const tagUpper = tag.toUpperCase();
          if (!result && allIds[tagUpper]) {
            result = new Error("Tag '" + tag + "' of custom rule at index " + customIndex + " is already used as a name.");
          }
          allIds[tagUpper] = false;
        });
      }
    });
    return result;
  }
  function newResults(ruleList) {
    const lintResults = {};
    function toString(useAlias) {
      let ruleNameToRule = null;
      const results = [];
      const keys = Object.keys(lintResults);
      keys.sort();
      keys.forEach(function forFile(file) {
        const fileResults = lintResults[file];
        if (Array.isArray(fileResults)) {
          fileResults.forEach(function forResult(result) {
            const ruleMoniker = result.ruleNames ? result.ruleNames.join("/") : result.ruleName + "/" + result.ruleAlias;
            results.push(file + ": " + result.lineNumber + ": " + ruleMoniker + " " + result.ruleDescription + (result.errorDetail ? " [" + result.errorDetail + "]" : "") + (result.errorContext ? ' [Context: "' + result.errorContext + '"]' : ""));
          });
        } else {
          if (!ruleNameToRule) {
            ruleNameToRule = {};
            ruleList.forEach(function forRule(rule) {
              const ruleName = rule.names[0].toUpperCase();
              ruleNameToRule[ruleName] = rule;
            });
          }
          Object.keys(fileResults).forEach(function forRule(ruleName) {
            const rule = ruleNameToRule[ruleName.toUpperCase()];
            const ruleResults = fileResults[ruleName];
            ruleResults.forEach(function forLine(lineNumber) {
              const nameIndex = Math.min(useAlias ? 1 : 0, rule.names.length - 1);
              const result = file + ": " + lineNumber + ": " + rule.names[nameIndex] + " " + rule.description;
              results.push(result);
            });
          });
        }
      });
      return results.join("\n");
    }
    Object.defineProperty(lintResults, "toString", {value: toString});
    return lintResults;
  }
  function removeFrontMatter(content, frontMatter) {
    let frontMatterLines = [];
    if (frontMatter) {
      const frontMatterMatch = content.match(frontMatter);
      if (frontMatterMatch && !frontMatterMatch.index) {
        const contentMatched = frontMatterMatch[0];
        content = content.slice(contentMatched.length);
        frontMatterLines = contentMatched.split(helpers.newLineRe);
        if (frontMatterLines.length > 0 && frontMatterLines[frontMatterLines.length - 1] === "") {
          frontMatterLines.length--;
        }
      }
    }
    return {
      content,
      frontMatterLines
    };
  }
  function annotateTokens(tokens, lines) {
    let tableMap = null;
    tokens.forEach(function forToken(token) {
      if (token.type === "thead_open" || token.type === "tbody_open") {
        tableMap = token.map.slice();
      } else if (token.type === "tr_close" && tableMap) {
        tableMap[0]++;
      } else if (token.type === "thead_close" || token.type === "tbody_close") {
        tableMap = null;
      }
      if (tableMap && !token.map) {
        token.map = tableMap.slice();
      }
      if (token.map) {
        token.line = lines[token.map[0]];
        token.lineNumber = token.map[0] + 1;
        while (token.map[1] && !(lines[token.map[1] - 1] || "").trim()) {
          token.map[1]--;
        }
        let lineNumber = token.lineNumber;
        const codeSpanExtraLines = [];
        helpers.forEachInlineCodeSpan(token.content, function handleInlineCodeSpan(code) {
          codeSpanExtraLines.push(code.split(helpers.newLineRe).length - 1);
        });
        (token.children || []).forEach(function forChild(child) {
          child.lineNumber = lineNumber;
          child.line = lines[lineNumber - 1];
          if (child.type === "softbreak" || child.type === "hardbreak") {
            lineNumber++;
          } else if (child.type === "code_inline") {
            lineNumber += codeSpanExtraLines.shift();
          }
        });
      }
    });
  }
  function mapAliasToRuleNames(ruleList) {
    const aliasToRuleNames = {};
    ruleList.forEach(function forRule(rule) {
      const ruleName = rule.names[0].toUpperCase();
      rule.names.forEach(function forName(name) {
        const nameUpper = name.toUpperCase();
        aliasToRuleNames[nameUpper] = [ruleName];
      });
      rule.tags.forEach(function forTag(tag) {
        const tagUpper = tag.toUpperCase();
        const ruleNames = aliasToRuleNames[tagUpper] || [];
        ruleNames.push(ruleName);
        aliasToRuleNames[tagUpper] = ruleNames;
      });
    });
    return aliasToRuleNames;
  }
  function getEffectiveConfig(ruleList, config2, aliasToRuleNames) {
    const defaultKey = Object.keys(config2).filter((key) => key.toUpperCase() === "DEFAULT");
    const ruleDefault = defaultKey.length === 0 || !!config2[defaultKey[0]];
    const effectiveConfig = {};
    ruleList.forEach((rule) => {
      const ruleName = rule.names[0].toUpperCase();
      effectiveConfig[ruleName] = ruleDefault;
    });
    deprecatedRuleNames.forEach((ruleName) => {
      effectiveConfig[ruleName] = false;
    });
    Object.keys(config2).forEach((key) => {
      let value = config2[key];
      if (value) {
        if (!(value instanceof Object)) {
          value = {};
        }
      } else {
        value = false;
      }
      const keyUpper = key.toUpperCase();
      (aliasToRuleNames[keyUpper] || []).forEach((ruleName) => {
        effectiveConfig[ruleName] = value;
      });
    });
    return effectiveConfig;
  }
  function getEnabledRulesPerLineNumber(ruleList, lines, frontMatterLines, noInlineConfig, config2, aliasToRuleNames) {
    let enabledRules = {};
    let capturedRules = {};
    const allRuleNames = [];
    const enabledRulesPerLineNumber = new Array(1 + frontMatterLines.length);
    function handleInlineConfig(perLine, forEachMatch, forEachLine) {
      const input = perLine ? lines : [lines.join("\n")];
      input.forEach((line, lineIndex) => {
        if (!noInlineConfig) {
          let match = null;
          while (match = helpers.inlineCommentRe.exec(line)) {
            const action = (match[1] || match[3]).toUpperCase();
            const parameter = match[2] || match[4];
            forEachMatch(action, parameter, lineIndex + 1);
          }
        }
        if (forEachLine) {
          forEachLine();
        }
      });
    }
    function configureFile(action, parameter) {
      if (action === "CONFIGURE-FILE") {
        try {
          const json = JSON.parse(parameter);
          config2 = {
            ...config2,
            ...json
          };
        } catch {
        }
      }
    }
    function applyEnableDisable(action, parameter, state) {
      const enabled = action.startsWith("ENABLE");
      const items = parameter ? parameter.trim().toUpperCase().split(/\s+/) : allRuleNames;
      items.forEach((nameUpper) => {
        (aliasToRuleNames[nameUpper] || []).forEach((ruleName) => {
          state[ruleName] = enabled;
        });
      });
    }
    function enableDisableFile(action, parameter) {
      if (action === "ENABLE-FILE" || action === "DISABLE-FILE") {
        applyEnableDisable(action, parameter, enabledRules);
      }
    }
    function captureRestoreEnableDisable(action, parameter) {
      if (action === "CAPTURE") {
        capturedRules = {...enabledRules};
      } else if (action === "RESTORE") {
        enabledRules = {...capturedRules};
      } else if (action === "ENABLE" || action === "DISABLE") {
        enabledRules = {...enabledRules};
        applyEnableDisable(action, parameter, enabledRules);
      }
    }
    function updateLineState() {
      enabledRulesPerLineNumber.push({...enabledRules});
    }
    function disableNextLine(action, parameter, lineNumber) {
      if (action === "DISABLE-NEXT-LINE") {
        applyEnableDisable(action, parameter, enabledRulesPerLineNumber[lineNumber + 1] || {});
      }
    }
    handleInlineConfig(false, configureFile);
    const effectiveConfig = getEffectiveConfig(ruleList, config2, aliasToRuleNames);
    ruleList.forEach((rule) => {
      const ruleName = rule.names[0].toUpperCase();
      allRuleNames.push(ruleName);
      enabledRules[ruleName] = !!effectiveConfig[ruleName];
    });
    capturedRules = enabledRules;
    handleInlineConfig(true, enableDisableFile);
    handleInlineConfig(true, captureRestoreEnableDisable, updateLineState);
    handleInlineConfig(true, disableNextLine);
    return {
      effectiveConfig,
      enabledRulesPerLineNumber
    };
  }
  function lineNumberComparison(a, b) {
    return a.lineNumber - b.lineNumber;
  }
  function filterAllValues() {
    return true;
  }
  function uniqueFilterForSortedErrors(value, index, array) {
    return index === 0 || value.lineNumber > array[index - 1].lineNumber;
  }
  function lintContent(ruleList, name, content, md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, callback) {
    content = content.replace(/^\uFEFF/, "");
    const removeFrontMatterResult = removeFrontMatter(content, frontMatter);
    const frontMatterLines = removeFrontMatterResult.frontMatterLines;
    content = helpers.clearHtmlCommentText(removeFrontMatterResult.content);
    const tokens = md.parse(content, {});
    const lines = content.split(helpers.newLineRe);
    annotateTokens(tokens, lines);
    const aliasToRuleNames = mapAliasToRuleNames(ruleList);
    const {effectiveConfig, enabledRulesPerLineNumber} = getEnabledRulesPerLineNumber(ruleList, lines, frontMatterLines, noInlineConfig, config2, aliasToRuleNames);
    const params = {
      name,
      tokens,
      lines,
      frontMatterLines
    };
    cache.lineMetadata(helpers.getLineMetadata(params));
    cache.flattenedLists(helpers.flattenLists(params));
    const result = resultVersion === 0 ? {} : [];
    function forRule(rule) {
      const ruleNameFriendly = rule.names[0];
      const ruleName = ruleNameFriendly.toUpperCase();
      params.config = effectiveConfig[ruleName];
      function throwError(property) {
        throw new Error("Property '" + property + "' of onError parameter is incorrect.");
      }
      const errors = [];
      function onError(errorInfo) {
        if (!errorInfo || !helpers.isNumber(errorInfo.lineNumber) || errorInfo.lineNumber < 1 || errorInfo.lineNumber > lines.length) {
          throwError("lineNumber");
        }
        if (errorInfo.detail && !helpers.isString(errorInfo.detail)) {
          throwError("detail");
        }
        if (errorInfo.context && !helpers.isString(errorInfo.context)) {
          throwError("context");
        }
        if (errorInfo.range && (!Array.isArray(errorInfo.range) || errorInfo.range.length !== 2 || !helpers.isNumber(errorInfo.range[0]) || errorInfo.range[0] < 1 || !helpers.isNumber(errorInfo.range[1]) || errorInfo.range[1] < 1 || errorInfo.range[0] + errorInfo.range[1] - 1 > lines[errorInfo.lineNumber - 1].length)) {
          throwError("range");
        }
        const fixInfo = errorInfo.fixInfo;
        const cleanFixInfo = {};
        if (fixInfo) {
          if (!helpers.isObject(fixInfo)) {
            throwError("fixInfo");
          }
          if (fixInfo.lineNumber !== void 0) {
            if (!helpers.isNumber(fixInfo.lineNumber) || fixInfo.lineNumber < 1 || fixInfo.lineNumber > lines.length) {
              throwError("fixInfo.lineNumber");
            }
            cleanFixInfo.lineNumber = fixInfo.lineNumber + frontMatterLines.length;
          }
          const effectiveLineNumber = fixInfo.lineNumber || errorInfo.lineNumber;
          if (fixInfo.editColumn !== void 0) {
            if (!helpers.isNumber(fixInfo.editColumn) || fixInfo.editColumn < 1 || fixInfo.editColumn > lines[effectiveLineNumber - 1].length + 1) {
              throwError("fixInfo.editColumn");
            }
            cleanFixInfo.editColumn = fixInfo.editColumn;
          }
          if (fixInfo.deleteCount !== void 0) {
            if (!helpers.isNumber(fixInfo.deleteCount) || fixInfo.deleteCount < -1 || fixInfo.deleteCount > lines[effectiveLineNumber - 1].length) {
              throwError("fixInfo.deleteCount");
            }
            cleanFixInfo.deleteCount = fixInfo.deleteCount;
          }
          if (fixInfo.insertText !== void 0) {
            if (!helpers.isString(fixInfo.insertText)) {
              throwError("fixInfo.insertText");
            }
            cleanFixInfo.insertText = fixInfo.insertText;
          }
        }
        errors.push({
          lineNumber: errorInfo.lineNumber + frontMatterLines.length,
          detail: errorInfo.detail || null,
          context: errorInfo.context || null,
          range: errorInfo.range ? [...errorInfo.range] : null,
          fixInfo: fixInfo ? cleanFixInfo : null
        });
      }
      if (handleRuleFailures) {
        try {
          rule.function(params, onError);
        } catch (error) {
          onError({
            lineNumber: 1,
            detail: `This rule threw an exception: ${error.message}`
          });
        }
      } else {
        rule.function(params, onError);
      }
      if (errors.length > 0) {
        errors.sort(lineNumberComparison);
        const filteredErrors = errors.filter(resultVersion === 3 ? filterAllValues : uniqueFilterForSortedErrors).filter(function removeDisabledRules(error) {
          return enabledRulesPerLineNumber[error.lineNumber][ruleName];
        }).map(function formatResults(error) {
          if (resultVersion === 0) {
            return error.lineNumber;
          }
          const errorObject = {};
          errorObject.lineNumber = error.lineNumber;
          if (resultVersion === 1) {
            errorObject.ruleName = ruleNameFriendly;
            errorObject.ruleAlias = rule.names[1] || rule.names[0];
          } else {
            errorObject.ruleNames = rule.names;
          }
          errorObject.ruleDescription = rule.description;
          errorObject.ruleInformation = rule.information ? rule.information.href : null;
          errorObject.errorDetail = error.detail;
          errorObject.errorContext = error.context;
          errorObject.errorRange = error.range;
          if (resultVersion === 3) {
            errorObject.fixInfo = error.fixInfo;
          }
          return errorObject;
        });
        if (filteredErrors.length > 0) {
          if (resultVersion === 0) {
            result[ruleNameFriendly] = filteredErrors;
          } else {
            Array.prototype.push.apply(result, filteredErrors);
          }
        }
      }
    }
    try {
      ruleList.forEach(forRule);
    } catch (error) {
      cache.clear();
      return callback(error);
    }
    cache.clear();
    return callback(null, result);
  }
  function lintFile(ruleList, file, md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, synchronous, callback) {
    function lintContentWrapper(err, content) {
      if (err) {
        return callback(err);
      }
      return lintContent(ruleList, file, content, md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, callback);
    }
    if (synchronous) {
      lintContentWrapper(null, fs2.readFileSync(file, helpers.utf8Encoding));
    } else {
      fs2.readFile(file, helpers.utf8Encoding, lintContentWrapper);
    }
  }
  function lintInput(options, synchronous, callback) {
    options = options || {};
    callback = callback || function noop() {
    };
    const ruleList = rules.concat(options.customRules || []);
    const ruleErr = validateRuleList(ruleList);
    if (ruleErr) {
      return callback(ruleErr);
    }
    let files = [];
    if (Array.isArray(options.files)) {
      files = options.files.slice();
    } else if (options.files) {
      files = [String(options.files)];
    }
    const strings = options.strings || {};
    const stringsKeys = Object.keys(strings);
    const config2 = options.config || {default: true};
    const frontMatter = options.frontMatter === void 0 ? helpers.frontMatterRe : options.frontMatter;
    const handleRuleFailures = !!options.handleRuleFailures;
    const noInlineConfig = !!options.noInlineConfig;
    const resultVersion = options.resultVersion === void 0 ? 2 : options.resultVersion;
    const md = markdownIt({html: true});
    const markdownItPlugins = options.markdownItPlugins || [];
    markdownItPlugins.forEach(function forPlugin(plugin) {
      md.use(...plugin);
    });
    const results = newResults(ruleList);
    let done = false;
    let syncItem = null;
    function syncCallback(err, result) {
      if (err) {
        done = true;
        return callback(err);
      }
      results[syncItem] = result;
      return null;
    }
    while (!done && (syncItem = stringsKeys.shift())) {
      lintContent(ruleList, syncItem, strings[syncItem] || "", md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, syncCallback);
    }
    if (synchronous) {
      while (!done && (syncItem = files.shift())) {
        lintFile(ruleList, syncItem, md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, synchronous, syncCallback);
      }
      return done || callback(null, results);
    }
    let concurrency = 0;
    function lintConcurrently() {
      const asyncItem = files.shift();
      if (done) {
      } else if (asyncItem) {
        concurrency++;
        lintFile(ruleList, asyncItem, md, config2, frontMatter, handleRuleFailures, noInlineConfig, resultVersion, synchronous, (err, result) => {
          concurrency--;
          if (err) {
            done = true;
            return callback(err);
          }
          results[asyncItem] = result;
          lintConcurrently();
          return null;
        });
      } else if (concurrency === 0) {
        done = true;
        return callback(null, results);
      }
      return null;
    }
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    lintConcurrently();
    return null;
  }
  function markdownlint2(options, callback) {
    return lintInput(options, false, callback);
  }
  var markdownlintPromisify = promisify && promisify(markdownlint2);
  function markdownlintPromise(options) {
    return markdownlintPromisify(options);
  }
  function markdownlintSync(options) {
    let results = null;
    lintInput(options, true, function callback(error, res) {
      if (error) {
        throw error;
      }
      results = res;
    });
    return results;
  }
  function parseConfiguration(name, content, parsers) {
    let config2 = null;
    let message = "";
    const errors = [];
    (parsers || [JSON.parse]).every((parser) => {
      try {
        config2 = parser(content);
      } catch (error) {
        errors.push(error.message);
      }
      return !config2;
    });
    if (!config2) {
      errors.unshift(`Unable to parse '${name}'`);
      message = errors.join("; ");
    }
    return {
      config: config2,
      message
    };
  }
  function resolveConfigExtends(configFile, referenceId) {
    const configFileDirname = path2.dirname(configFile);
    const resolvedExtendsFile = path2.resolve(configFileDirname, referenceId);
    try {
      if (fs2.statSync(resolvedExtendsFile).isFile()) {
        return resolvedExtendsFile;
      }
    } catch {
    }
    try {
      return dynamicRequire.resolve(referenceId, {paths: [configFileDirname]});
    } catch {
    }
    return resolvedExtendsFile;
  }
  function readConfig(file, parsers, callback) {
    if (!callback) {
      callback = parsers;
      parsers = null;
    }
    fs2.readFile(file, helpers.utf8Encoding, (err, content) => {
      if (err) {
        return callback(err);
      }
      const {config: config2, message} = parseConfiguration(file, content, parsers);
      if (!config2) {
        return callback(new Error(message));
      }
      const configExtends = config2.extends;
      if (configExtends) {
        delete config2.extends;
        const resolvedExtends = resolveConfigExtends(file, configExtends);
        return readConfig(resolvedExtends, parsers, (errr, extendsConfig) => {
          if (errr) {
            return callback(errr);
          }
          return callback(null, {
            ...extendsConfig,
            ...config2
          });
        });
      }
      return callback(null, config2);
    });
  }
  var readConfigPromisify = promisify && promisify(readConfig);
  function readConfigPromise(file, parsers) {
    return readConfigPromisify(file, parsers);
  }
  function readConfigSync(file, parsers) {
    const content = fs2.readFileSync(file, helpers.utf8Encoding);
    const {config: config2, message} = parseConfiguration(file, content, parsers);
    if (!config2) {
      throw new Error(message);
    }
    const configExtends = config2.extends;
    if (configExtends) {
      delete config2.extends;
      const resolvedExtends = resolveConfigExtends(file, configExtends);
      return {
        ...readConfigSync(resolvedExtends, parsers),
        ...config2
      };
    }
    return config2;
  }
  function getVersion() {
    return require_package().version;
  }
  markdownlint2.sync = markdownlintSync;
  markdownlint2.readConfig = readConfig;
  markdownlint2.readConfigSync = readConfigSync;
  markdownlint2.getVersion = getVersion;
  markdownlint2.promises = {
    markdownlint: markdownlintPromise,
    readConfig: readConfigPromise
  };
  module2.exports = markdownlint2;
});

// node_modules/markdownlint-rule-helpers/helpers.js
var require_helpers3 = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var newLineRe = /\r\n?|\n/g;
  module2.exports.newLineRe = newLineRe;
  module2.exports.frontMatterRe = /((^---\s*$[^]*?^---\s*$)|(^\+\+\+\s*$[^]*?^(\+\+\+|\.\.\.)\s*$)|(^\{\s*$[^]*?^\}\s*$))(\r\n|\r|\n|$)/m;
  var inlineCommentRe = /<!--\s*markdownlint-(?:(?:(disable|enable|capture|restore|disable-file|enable-file|disable-next-line)((?:\s+[a-z0-9_-]+)*))|(?:(configure-file)\s+([\s\S]*?)))\s*-->/ig;
  module2.exports.inlineCommentRe = inlineCommentRe;
  module2.exports.bareUrlRe = /(?:http|ftp)s?:\/\/[^\s\]"']*(?:\/|[^\s\]"'\W])/ig;
  module2.exports.listItemMarkerRe = /^([\s>]*)(?:[*+-]|\d+[.)])\s+/;
  module2.exports.orderedListItemMarkerRe = /^[\s>]*0*(\d+)[.)]/;
  var emphasisMarkersRe = /[_*]/g;
  var linkRe = /\[(?:[^[\]]|\[[^\]]*\])*\](?:\(\S*\))?/g;
  module2.exports.utf8Encoding = "utf8";
  var allPunctuation = ".,;:!?\u3002\uFF0C\uFF1B\uFF1A\uFF01\uFF1F";
  module2.exports.allPunctuation = allPunctuation;
  module2.exports.allPunctuationNoQuestion = allPunctuation.replace(/[?？]/gu, "");
  module2.exports.isNumber = function isNumber(obj) {
    return typeof obj === "number";
  };
  module2.exports.isString = function isString(obj) {
    return typeof obj === "string";
  };
  module2.exports.isEmptyString = function isEmptyString(str) {
    return str.length === 0;
  };
  module2.exports.isObject = function isObject(obj) {
    return obj !== null && typeof obj === "object" && !Array.isArray(obj);
  };
  var blankLineRe = />|(?:<!--.*?-->)/g;
  module2.exports.isBlankLine = function isBlankLine(line) {
    return !line || !line.trim() || !line.replace(blankLineRe, "").trim();
  };
  module2.exports.numericSortAscending = function numericSortAscending(a, b) {
    return a - b;
  };
  module2.exports.includesSorted = function includesSorted(array, element) {
    let left = 0;
    let right = array.length - 1;
    while (left <= right) {
      const mid = left + right >> 1;
      if (array[mid] < element) {
        left = mid + 1;
      } else if (array[mid] > element) {
        right = mid - 1;
      } else {
        return true;
      }
    }
    return false;
  };
  var htmlCommentBegin = "<!--";
  var htmlCommentEnd = "-->";
  module2.exports.clearHtmlCommentText = function clearHtmlCommentText(text) {
    let i = 0;
    while ((i = text.indexOf(htmlCommentBegin, i)) !== -1) {
      const j = text.indexOf(htmlCommentEnd, i + 2);
      if (j === -1) {
        break;
      }
      if (j > i + htmlCommentBegin.length) {
        let k = i - 1;
        while (text[k] === " ") {
          k--;
        }
        if (k >= i - 4) {
          const content = text.slice(i + htmlCommentBegin.length, j);
          const isBlock = k < 0 || text[k] === "\n";
          const isValid = isBlock || !content.startsWith(">") && !content.startsWith("->") && !content.endsWith("-") && !content.includes("--");
          if (isValid) {
            const inlineCommentIndex = text.slice(i, j + htmlCommentEnd.length).search(inlineCommentRe);
            if (inlineCommentIndex === -1) {
              text = text.slice(0, i + htmlCommentBegin.length) + content.replace(/[^\r\n]/g, ".") + text.slice(j);
            }
          }
        }
      }
      i = j + htmlCommentEnd.length;
    }
    return text;
  };
  module2.exports.escapeForRegExp = function escapeForRegExp(str) {
    return str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  };
  var escapedMarkdownRe = /\\./g;
  module2.exports.unescapeMarkdown = function unescapeMarkdown(markdown, replacement) {
    return markdown.replace(escapedMarkdownRe, (match) => {
      const char = match[1];
      if ("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~".includes(char)) {
        return replacement || char;
      }
      return match;
    });
  };
  module2.exports.fencedCodeBlockStyleFor = function fencedCodeBlockStyleFor(markup) {
    switch (markup[0]) {
      case "~":
        return "tilde";
      default:
        return "backtick";
    }
  };
  function indentFor(token) {
    const line = token.line.replace(/^[\s>]*(> |>)/, "");
    return line.length - line.trimStart().length;
  }
  module2.exports.indentFor = indentFor;
  module2.exports.headingStyleFor = function headingStyleFor(token) {
    if (token.map[1] - token.map[0] === 1) {
      if (/[^\\]#\s*$/.test(token.line)) {
        return "atx_closed";
      }
      return "atx";
    }
    return "setext";
  };
  module2.exports.unorderedListStyleFor = function unorderedListStyleFor(token) {
    switch (token.markup) {
      case "-":
        return "dash";
      case "+":
        return "plus";
      default:
        return "asterisk";
    }
  };
  function filterTokens(params, type, handler) {
    params.tokens.forEach(function forToken(token) {
      if (token.type === type) {
        handler(token);
      }
    });
  }
  module2.exports.filterTokens = filterTokens;
  function isMathBlock(token) {
    return token.tag === "math" && token.type.startsWith("math_block") && !token.type.endsWith("_end");
  }
  module2.exports.getLineMetadata = function getLineMetadata(params) {
    const lineMetadata = params.lines.map((line, index) => [line, index, false, 0, false, false, false, false]);
    filterTokens(params, "fence", (token) => {
      lineMetadata[token.map[0]][3] = 1;
      lineMetadata[token.map[1] - 1][3] = -1;
      for (let i = token.map[0] + 1; i < token.map[1] - 1; i++) {
        lineMetadata[i][2] = true;
      }
    });
    filterTokens(params, "code_block", (token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][2] = true;
      }
    });
    filterTokens(params, "table_open", (token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][4] = true;
      }
    });
    filterTokens(params, "list_item_open", (token) => {
      let count = 1;
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][5] = count;
        count++;
      }
    });
    filterTokens(params, "hr", (token) => {
      lineMetadata[token.map[0]][6] = true;
    });
    params.tokens.filter(isMathBlock).forEach((token) => {
      for (let i = token.map[0]; i < token.map[1]; i++) {
        lineMetadata[i][7] = true;
      }
    });
    return lineMetadata;
  };
  module2.exports.forEachLine = function forEachLine(lineMetadata, handler) {
    lineMetadata.forEach(function forMetadata(metadata) {
      handler(...metadata);
    });
  };
  module2.exports.flattenLists = function flattenLists(params) {
    const flattenedLists = [];
    const stack = [];
    let current = null;
    let nesting = 0;
    const nestingStack = [];
    let lastWithMap = {map: [0, 1]};
    params.tokens.forEach((token) => {
      if (isMathBlock(token) && token.map[1]) {
        token.map[1]++;
      }
      if (token.type === "bullet_list_open" || token.type === "ordered_list_open") {
        stack.push(current);
        current = {
          unordered: token.type === "bullet_list_open",
          parentsUnordered: !current || current.unordered && current.parentsUnordered,
          open: token,
          indent: indentFor(token),
          parentIndent: current && current.indent || 0,
          items: [],
          nesting,
          lastLineIndex: -1,
          insert: flattenedLists.length
        };
        nesting++;
      } else if (token.type === "bullet_list_close" || token.type === "ordered_list_close") {
        current.lastLineIndex = lastWithMap.map[1];
        flattenedLists.splice(current.insert, 0, current);
        delete current.insert;
        current = stack.pop();
        nesting--;
      } else if (token.type === "list_item_open") {
        current.items.push(token);
      } else if (token.type === "blockquote_open") {
        nestingStack.push(nesting);
        nesting = 0;
      } else if (token.type === "blockquote_close") {
        nesting = nestingStack.pop();
      } else if (token.map) {
        lastWithMap = token;
      }
    });
    return flattenedLists;
  };
  module2.exports.forEachInlineChild = function forEachInlineChild(params, type, handler) {
    filterTokens(params, "inline", function forToken(token) {
      token.children.forEach(function forChild(child) {
        if (child.type === type) {
          handler(child, token);
        }
      });
    });
  };
  module2.exports.forEachHeading = function forEachHeading(params, handler) {
    let heading = null;
    params.tokens.forEach(function forToken(token) {
      if (token.type === "heading_open") {
        heading = token;
      } else if (token.type === "heading_close") {
        heading = null;
      } else if (token.type === "inline" && heading) {
        handler(heading, token.content);
      }
    });
  };
  function forEachInlineCodeSpan(input, handler) {
    let currentLine = 0;
    let currentColumn = 0;
    let index = 0;
    while (index < input.length) {
      let startIndex = -1;
      let startLine = -1;
      let startColumn = -1;
      let tickCount = 0;
      let currentTicks = 0;
      let state = "normal";
      for (; index <= input.length; index++) {
        const char = input[index];
        if (char === "[" && state === "normal") {
          state = "linkTextOpen";
        } else if (char === "]" && state === "linkTextOpen") {
          state = "linkTextClosed";
        } else if (char === "(" && state === "linkTextClosed") {
          state = "linkDestinationOpen";
        } else if (char === "(" && state === "linkDestinationOpen" || char === ")" && state === "linkDestinationOpen" || state === "linkTextClosed") {
          state = "normal";
        }
        if (char === "`" && state !== "linkDestinationOpen") {
          currentTicks++;
          if (startIndex === -1 || startColumn === -1) {
            startIndex = index + 1;
          }
        } else {
          if (startIndex >= 0 && startColumn >= 0 && tickCount === currentTicks) {
            handler(input.substring(startIndex, index - currentTicks), startLine, startColumn, tickCount);
            startIndex = -1;
            startColumn = -1;
          } else if (startIndex >= 0 && startColumn === -1) {
            tickCount = currentTicks;
            startLine = currentLine;
            startColumn = currentColumn;
          }
          currentTicks = 0;
        }
        if (char === "\n") {
          currentLine++;
          currentColumn = 0;
        } else if (char === "\\" && (startIndex === -1 || startColumn === -1) && input[index + 1] !== "\n") {
          index++;
          currentColumn += 2;
        } else {
          currentColumn++;
        }
      }
      if (startIndex >= 0) {
        index = startIndex;
        currentLine = startLine;
        currentColumn = startColumn;
      }
    }
  }
  module2.exports.forEachInlineCodeSpan = forEachInlineCodeSpan;
  function addError(onError, lineNumber, detail, context, range, fixInfo) {
    onError({
      lineNumber,
      detail,
      context,
      range,
      fixInfo
    });
  }
  module2.exports.addError = addError;
  module2.exports.addErrorDetailIf = function addErrorDetailIf(onError, lineNumber, expected, actual, detail, context, range, fixInfo) {
    if (expected !== actual) {
      addError(onError, lineNumber, "Expected: " + expected + "; Actual: " + actual + (detail ? "; " + detail : ""), context, range, fixInfo);
    }
  };
  module2.exports.addErrorContext = function addErrorContext(onError, lineNumber, context, left, right, range, fixInfo) {
    if (context.length <= 30) {
    } else if (left && right) {
      context = context.substr(0, 15) + "..." + context.substr(-15);
    } else if (right) {
      context = "..." + context.substr(-30);
    } else {
      context = context.substr(0, 30) + "...";
    }
    addError(onError, lineNumber, null, context, range, fixInfo);
  };
  module2.exports.rangeFromRegExp = function rangeFromRegExp(line, regexp) {
    let range = null;
    const match = line.match(regexp);
    if (match) {
      const column = match.index + 1;
      const length = match[0].length;
      range = [column, length];
    }
    return range;
  };
  module2.exports.frontMatterHasTitle = function frontMatterHasTitle(frontMatterLines, frontMatterTitlePattern) {
    const ignoreFrontMatter = frontMatterTitlePattern !== void 0 && !frontMatterTitlePattern;
    const frontMatterTitleRe = new RegExp(String(frontMatterTitlePattern || '^\\s*"?title"?\\s*[:=]'), "i");
    return !ignoreFrontMatter && frontMatterLines.some((line) => frontMatterTitleRe.test(line));
  };
  function emphasisMarkersInContent(params) {
    const {lines} = params;
    const byLine = new Array(lines.length);
    filterTokens(params, "inline", (token) => {
      const {children, lineNumber, map} = token;
      if (children.some((child) => child.type === "code_inline")) {
        const tokenLines = lines.slice(map[0], map[1]);
        forEachInlineCodeSpan(tokenLines.join("\n"), (code, lineIndex, column, tickCount) => {
          const codeLines = code.split(newLineRe);
          codeLines.forEach((codeLine, codeLineIndex) => {
            let match = null;
            while (match = emphasisMarkersRe.exec(codeLine)) {
              const byLineIndex = lineNumber - 1 + lineIndex + codeLineIndex;
              const inLine = byLine[byLineIndex] || [];
              const codeLineOffset = codeLineIndex ? 0 : column - 1 + tickCount;
              inLine.push(codeLineOffset + match.index);
              byLine[byLineIndex] = inLine;
            }
          });
        });
      }
    });
    lines.forEach((tokenLine, tokenLineIndex) => {
      let linkMatch = null;
      while (linkMatch = linkRe.exec(tokenLine)) {
        let markerMatch = null;
        while (markerMatch = emphasisMarkersRe.exec(linkMatch[0])) {
          const inLine = byLine[tokenLineIndex] || [];
          inLine.push(linkMatch.index + markerMatch.index);
          byLine[tokenLineIndex] = inLine;
        }
      }
    });
    return byLine;
  }
  module2.exports.emphasisMarkersInContent = emphasisMarkersInContent;
  function getPreferredLineEnding(input) {
    let cr = 0;
    let lf = 0;
    let crlf = 0;
    const endings = input.match(newLineRe) || [];
    endings.forEach((ending) => {
      switch (ending) {
        case "\r":
          cr++;
          break;
        case "\n":
          lf++;
          break;
        case "\r\n":
          crlf++;
          break;
      }
    });
    let preferredLineEnding = null;
    if (!cr && !lf && !crlf) {
      preferredLineEnding = os.EOL;
    } else if (lf >= crlf && lf >= cr) {
      preferredLineEnding = "\n";
    } else if (crlf >= cr) {
      preferredLineEnding = "\r\n";
    } else {
      preferredLineEnding = "\r";
    }
    return preferredLineEnding;
  }
  module2.exports.getPreferredLineEnding = getPreferredLineEnding;
  function normalizeFixInfo(fixInfo, lineNumber) {
    return {
      lineNumber: fixInfo.lineNumber || lineNumber,
      editColumn: fixInfo.editColumn || 1,
      deleteCount: fixInfo.deleteCount || 0,
      insertText: fixInfo.insertText || ""
    };
  }
  function applyFix2(line, fixInfo, lineEnding) {
    const {editColumn, deleteCount, insertText} = normalizeFixInfo(fixInfo);
    const editIndex = editColumn - 1;
    return deleteCount === -1 ? null : line.slice(0, editIndex) + insertText.replace(/\n/g, lineEnding || "\n") + line.slice(editIndex + deleteCount);
  }
  module2.exports.applyFix = applyFix2;
  module2.exports.applyFixes = function applyFixes2(input, errors) {
    const lineEnding = getPreferredLineEnding(input);
    const lines = input.split(newLineRe);
    let fixInfos = errors.filter((error) => error.fixInfo).map((error) => normalizeFixInfo(error.fixInfo, error.lineNumber));
    fixInfos.sort((a, b) => {
      const aDeletingLine = a.deleteCount === -1;
      const bDeletingLine = b.deleteCount === -1;
      return b.lineNumber - a.lineNumber || (aDeletingLine ? 1 : bDeletingLine ? -1 : 0) || b.editColumn - a.editColumn || b.insertText.length - a.insertText.length;
    });
    let lastFixInfo = {};
    fixInfos = fixInfos.filter((fixInfo) => {
      const unique = fixInfo.lineNumber !== lastFixInfo.lineNumber || fixInfo.editColumn !== lastFixInfo.editColumn || fixInfo.deleteCount !== lastFixInfo.deleteCount || fixInfo.insertText !== lastFixInfo.insertText;
      lastFixInfo = fixInfo;
      return unique;
    });
    lastFixInfo = {};
    fixInfos.forEach((fixInfo) => {
      if (fixInfo.lineNumber === lastFixInfo.lineNumber && fixInfo.editColumn === lastFixInfo.editColumn && !fixInfo.insertText && fixInfo.deleteCount > 0 && lastFixInfo.insertText && !lastFixInfo.deleteCount) {
        fixInfo.insertText = lastFixInfo.insertText;
        lastFixInfo.lineNumber = 0;
      }
      lastFixInfo = fixInfo;
    });
    fixInfos = fixInfos.filter((fixInfo) => fixInfo.lineNumber);
    let lastLineIndex = -1;
    let lastEditIndex = -1;
    fixInfos.forEach((fixInfo) => {
      const {lineNumber, editColumn, deleteCount} = fixInfo;
      const lineIndex = lineNumber - 1;
      const editIndex = editColumn - 1;
      if (lineIndex !== lastLineIndex || deleteCount === -1 || editIndex + deleteCount <= lastEditIndex - (deleteCount > 0 ? 0 : 1)) {
        lines[lineIndex] = applyFix2(lines[lineIndex], fixInfo, lineEnding);
      }
      lastLineIndex = lineIndex;
      lastEditIndex = editIndex;
    });
    return lines.filter((line) => line !== null).join(lineEnding);
  };
});

// node_modules/ini/ini.js
var require_ini = __commonJS((exports2) => {
  exports2.parse = exports2.decode = decode;
  exports2.stringify = exports2.encode = encode;
  exports2.safe = safe;
  exports2.unsafe = unsafe;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  function encode(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || Object.create(null);
      opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      if (val && Array.isArray(val)) {
        val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + "\n";
        });
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\.");
      var section = (opt.section ? opt.section + "." : "") + nk;
      var child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    });
    return out;
  }
  function dotSplit(str) {
    return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str) {
    var out = Object.create(null);
    var p = out;
    var section = null;
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
      if (!line || line.match(/^\s*[;#]/))
        return;
      var match = line.match(re);
      if (!match)
        return;
      if (match[1] !== void 0) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = Object.create(null);
          return;
        }
        p = out[section] = out[section] || Object.create(null);
        return;
      }
      var key = unsafe(match[2]);
      if (key === "__proto__")
        return;
      var value = match[3] ? unsafe(match[4]) : true;
      switch (value) {
        case "true":
        case "false":
        case "null":
          value = JSON.parse(value);
      }
      if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2);
        if (key === "__proto__")
          return;
        if (!p[key])
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    });
    Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
        return false;
      var parts = dotSplit(k);
      var p2 = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, ".");
      parts.forEach(function(part, _2, __2) {
        if (part === "__proto__")
          return;
        if (!p2[part] || typeof p2[part] !== "object")
          p2[part] = Object.create(null);
        p2 = p2[part];
      });
      if (p2 === out && nl === l)
        return false;
      p2[nl] = out[k];
      return true;
    }).forEach(function(del, _, __) {
      delete out[del];
    });
    return out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_) {
      }
    } else {
      var esc = false;
      var unesc = "";
      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS((exports2, module2) => {
  "use strict";
  var singleComment = 1;
  var multiComment = 2;
  function stripWithoutWhitespace() {
    return "";
  }
  function stripWithWhitespace(str, start, end) {
    return str.slice(start, end).replace(/\S/g, " ");
  }
  module2.exports = function(str, opts) {
    opts = opts || {};
    var currentChar;
    var nextChar;
    var insideString = false;
    var insideComment = false;
    var offset = 0;
    var ret = "";
    var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
    for (var i = 0; i < str.length; i++) {
      currentChar = str[i];
      nextChar = str[i + 1];
      if (!insideComment && currentChar === '"') {
        var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
        if (!escaped) {
          insideString = !insideString;
        }
      }
      if (insideString) {
        continue;
      }
      if (!insideComment && currentChar + nextChar === "//") {
        ret += str.slice(offset, i);
        offset = i;
        insideComment = singleComment;
        i++;
      } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
        i++;
        insideComment = false;
        ret += strip(str, offset, i);
        offset = i;
        continue;
      } else if (insideComment === singleComment && currentChar === "\n") {
        insideComment = false;
        ret += strip(str, offset, i);
        offset = i;
      } else if (!insideComment && currentChar + nextChar === "/*") {
        ret += str.slice(offset, i);
        offset = i;
        insideComment = multiComment;
        i++;
        continue;
      } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
        i++;
        insideComment = false;
        ret += strip(str, offset, i + 1);
        offset = i + 1;
        continue;
      }
    }
    return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
  };
});

// node_modules/rc/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  var fs2 = require("fs");
  var ini = require_ini();
  var path2 = require("path");
  var stripJsonComments = require_strip_json_comments();
  var parse = exports2.parse = function(content) {
    if (/^\s*{/.test(content))
      return JSON.parse(stripJsonComments(content));
    return ini.parse(content);
  };
  var file = exports2.file = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    });
    for (var i in args)
      if (typeof args[i] !== "string")
        return;
    var file2 = path2.join.apply(null, args);
    var content;
    try {
      return fs2.readFileSync(file2, "utf-8");
    } catch (err) {
      return;
    }
  };
  var json = exports2.json = function() {
    var content = file.apply(null, arguments);
    return content ? parse(content) : null;
  };
  var env = exports2.env = function(prefix, env2) {
    env2 = env2 || process.env;
    var obj = {};
    var l = prefix.length;
    for (var k in env2) {
      if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        var keypath = k.substring(l).split("__");
        var _emptyStringIndex;
        while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
          keypath.splice(_emptyStringIndex, 1);
        }
        var cursor = obj;
        keypath.forEach(function _buildSubObj(_subkey, i) {
          if (!_subkey || typeof cursor !== "object")
            return;
          if (i === keypath.length - 1)
            cursor[_subkey] = env2[k];
          if (cursor[_subkey] === void 0)
            cursor[_subkey] = {};
          cursor = cursor[_subkey];
        });
      }
    }
    return obj;
  };
  var find = exports2.find = function() {
    var rel = path2.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file2 = path2.join(start, rel2);
      try {
        fs2.statSync(file2);
        return file2;
      } catch (err) {
        if (path2.dirname(start) !== start)
          return find2(path2.dirname(start), rel2);
      }
    }
    return find2(process.cwd(), rel);
  };
});

// node_modules/minimist/index.js
var require_minimist = __commonJS((exports2, module2) => {
  module2.exports = function(args, opts) {
    if (!opts)
      opts = {};
    var flags = {bools: {}, strings: {}, unknownFn: null};
    if (typeof opts["unknown"] === "function") {
      flags.unknownFn = opts["unknown"];
    }
    if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
      flags.allBools = true;
    } else {
      [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = true;
      });
    }
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function(key2) {
      aliases[key2] = [].concat(opts.alias[key2]);
      aliases[key2].forEach(function(x) {
        aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
          return x !== y;
        }));
      });
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key2) {
      flags.strings[key2] = true;
      if (aliases[key2]) {
        flags.strings[aliases[key2]] = true;
      }
    });
    var defaults = opts["default"] || {};
    var argv = {_: []};
    Object.keys(flags.bools).forEach(function(key2) {
      setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
    });
    var notFlags = [];
    if (args.indexOf("--") !== -1) {
      notFlags = args.slice(args.indexOf("--") + 1);
      args = args.slice(0, args.indexOf("--"));
    }
    function argDefined(key2, arg2) {
      return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
    }
    function setArg(key2, val, arg2) {
      if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
        if (flags.unknownFn(arg2) === false)
          return;
      }
      var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
      setKey(argv, key2.split("."), value2);
      (aliases[key2] || []).forEach(function(x) {
        setKey(argv, x.split("."), value2);
      });
    }
    function setKey(obj, keys, value2) {
      var o = obj;
      for (var i2 = 0; i2 < keys.length - 1; i2++) {
        var key2 = keys[i2];
        if (key2 === "__proto__")
          return;
        if (o[key2] === void 0)
          o[key2] = {};
        if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
          o[key2] = {};
        if (o[key2] === Array.prototype)
          o[key2] = [];
        o = o[key2];
      }
      var key2 = keys[keys.length - 1];
      if (key2 === "__proto__")
        return;
      if (o === Object.prototype || o === Number.prototype || o === String.prototype)
        o = {};
      if (o === Array.prototype)
        o = [];
      if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
        o[key2] = value2;
      } else if (Array.isArray(o[key2])) {
        o[key2].push(value2);
      } else {
        o[key2] = [o[key2], value2];
      }
    }
    function aliasIsBoolean(key2) {
      return aliases[key2].some(function(x) {
        return flags.bools[x];
      });
    }
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        var key = m[1];
        var value = m[2];
        if (flags.bools[key]) {
          value = value !== "false";
        }
        setArg(key, value, arg);
      } else if (/^--no-.+/.test(arg)) {
        var key = arg.match(/^--no-(.+)/)[1];
        setArg(key, false, arg);
      } else if (/^--.+/.test(arg)) {
        var key = arg.match(/^--(.+)/)[1];
        var next = args[i + 1];
        if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, next, arg);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next === "true", arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? "" : true, arg);
        }
      } else if (/^-[^-]+/.test(arg)) {
        var letters = arg.slice(1, -1).split("");
        var broken = false;
        for (var j = 0; j < letters.length; j++) {
          var next = arg.slice(j + 2);
          if (next === "-") {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
            setArg(letters[j], next.split("=")[1], arg);
            broken = true;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg);
            broken = true;
            break;
          } else {
            setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
          }
        }
        var key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, args[i + 1], arg);
            i++;
          } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
            setArg(key, args[i + 1] === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        }
      } else {
        if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
          argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
        }
        if (opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
    }
    Object.keys(defaults).forEach(function(key2) {
      if (!hasKey(argv, key2.split("."))) {
        setKey(argv, key2.split("."), defaults[key2]);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), defaults[key2]);
        });
      }
    });
    if (opts["--"]) {
      argv["--"] = new Array();
      notFlags.forEach(function(key2) {
        argv["--"].push(key2);
      });
    } else {
      notFlags.forEach(function(key2) {
        argv._.push(key2);
      });
    }
    return argv;
  };
  function hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key2) {
      o = o[key2] || {};
    });
    var key = keys[keys.length - 1];
    return key in o;
  }
  function isNumber(x) {
    if (typeof x === "number")
      return true;
    if (/^0x[0-9a-f]+$/i.test(x))
      return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS((exports2, module2) => {
  var cc = require_utils2();
  var join = require("path").join;
  var deepExtend = require_deep_extend();
  var etc = "/etc";
  var win = process.platform === "win32";
  var home = win ? process.env.USERPROFILE : process.env.HOME;
  module2.exports = function(name, defaults, argv, parse) {
    if (typeof name !== "string")
      throw new Error("rc(name): name *must* be string");
    if (!argv)
      argv = require_minimist()(process.argv.slice(2));
    defaults = (typeof defaults === "string" ? cc.json(defaults) : defaults) || {};
    parse = parse || cc.parse;
    var env = cc.env(name + "_");
    var configs = [defaults];
    var configFiles = [];
    function addConfigFile(file) {
      if (configFiles.indexOf(file) >= 0)
        return;
      var fileConfig = cc.file(file);
      if (fileConfig) {
        configs.push(parse(fileConfig));
        configFiles.push(file);
      }
    }
    if (!win)
      [
        join(etc, name, "config"),
        join(etc, name + "rc")
      ].forEach(addConfigFile);
    if (home)
      [
        join(home, ".config", name, "config"),
        join(home, ".config", name),
        join(home, "." + name, "config"),
        join(home, "." + name + "rc")
      ].forEach(addConfigFile);
    addConfigFile(cc.find("." + name + "rc"));
    if (env.config)
      addConfigFile(env.config);
    if (argv.config)
      addConfigFile(argv.config);
    return deepExtend.apply(null, configs.concat([
      env,
      argv,
      configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : void 0
    ]));
  };
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc2 = __toModule(require("coc.nvim"));

// src/engine.ts
var import_coc = __toModule(require("coc.nvim"));
var import_deep_extend = __toModule(require_deep_extend());
var import_fs = __toModule(require("fs"));
var import_js_yaml = __toModule(require_js_yaml2());
var import_markdownlint = __toModule(require_markdownlint());
var import_markdownlint_rule_helpers = __toModule(require_helpers3());
var import_path = __toModule(require("path"));
var import_rc = __toModule(require_rc());
var projectConfigFiles = [".markdownlint.json", ".markdownlint.yaml", ".markdownlint.yml"];
var configFileParsers = [JSON.parse, import_js_yaml.default.safeLoad];
var MarkdownlintEngine = class {
  constructor() {
    this.fixAllCommandName = "markdownlint.fixAll";
    this.source = "markdownlint";
    this.outputChannel = import_coc.window.createOutputChannel(this.source);
    this.diagnosticCollection = import_coc.languages.createDiagnosticCollection(this.source);
    this.config = {};
  }
  outputLine(message) {
    if (this.outputChannel) {
      this.outputChannel.appendLine(`[${new Date().toLocaleTimeString()}] ${message}`);
    }
  }
  async parseConfig() {
    try {
      this.config = import_rc.default(this.source, {});
      this.outputLine(`Info: global config: ${JSON.stringify(import_rc.default(this.source, {}))}`);
    } catch (e) {
      this.outputLine(`Error: global config parse failed: ${e}`);
    }
    try {
      for (const projectConfigFile of projectConfigFiles) {
        const fullPath = import_path.default.join(import_coc.workspace.root, projectConfigFile);
        if (import_fs.default.existsSync(fullPath)) {
          const projectConfig = import_markdownlint.default.readConfigSync(fullPath, configFileParsers);
          this.config = import_deep_extend.default(this.config, projectConfig);
          this.outputLine(`Info: local config: ${fullPath}, ${JSON.stringify(projectConfig)}`);
          break;
        }
      }
    } catch (e) {
      this.outputLine(`Error: local config parse failed: ${e}`);
    }
    const cocConfig = import_coc.workspace.getConfiguration("markdownlint").get("config");
    if (cocConfig) {
      this.config = import_deep_extend.default(this.config, cocConfig);
      this.outputLine(`Info: config from coc-settings.json: ${JSON.stringify(cocConfig)}`);
    }
    this.outputLine(`Info: full config: ${JSON.stringify(this.config)}`);
  }
  markdownlintWrapper(document) {
    const options = {
      resultVersion: 3,
      config: this.config,
      strings: {
        [document.uri]: document.getText()
      }
    };
    let results = [];
    try {
      results = import_markdownlint.default.sync(options)[document.uri];
    } catch (e) {
      this.outputLine(`Error: lint exception: ${e.stack}`);
    }
    return results;
  }
  async provideCodeActions(document, range, context) {
    const doc = import_coc.workspace.getDocument(document.uri);
    const wholeRange = import_coc.Range.create(0, 0, doc.lineCount, 0);
    let whole = false;
    if (range.start.line === wholeRange.start.line && range.start.character === wholeRange.start.character && range.end.line === wholeRange.end.line && range.end.character === wholeRange.end.character) {
      whole = true;
    }
    const codeActions = [];
    const fixInfoDiagnostics = [];
    for (const diagnostic of context.diagnostics) {
      if (diagnostic.fixInfo) {
        const lineNumber = diagnostic.fixInfo.lineNumber - 1 || diagnostic.range.start.line;
        const line = await import_coc.workspace.getLine(document.uri, lineNumber);
        const newText = import_markdownlint_rule_helpers.applyFix(line, diagnostic.fixInfo, "\n");
        const edit = {changes: {}};
        if (typeof newText === "string") {
          const range2 = import_coc.Range.create(lineNumber, 0, lineNumber, line.length);
          edit.changes[document.uri] = [import_coc.TextEdit.replace(range2, newText)];
        } else {
          edit.changes[document.uri] = [import_coc.TextEdit.del(diagnostic.range)];
        }
        const title = `Fix: ${diagnostic.message.split(":")[0]}`;
        const action = {
          title,
          edit,
          diagnostics: [...context.diagnostics]
        };
        fixInfoDiagnostics.push(diagnostic);
        if (!whole) {
          codeActions.push(action);
        }
      }
    }
    if (range.start.line === range.end.line && range.start.character === 0) {
      const edit = import_coc.TextEdit.insert(import_coc.Position.create(range.start.line, 0), "<!-- markdownlint-disable-next-line -->\n");
      codeActions.push({
        title: "Disable markdownlint for current line",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (whole) {
      const edit = import_coc.TextEdit.insert(import_coc.Position.create(0, 0), "<!-- markdownlint-disable-file -->\n");
      codeActions.push({
        title: "Disable markdownlint for current file",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (fixInfoDiagnostics.length) {
      const title = "Fix All error found by markdownlint";
      const sourceFixAllAction = {
        title,
        kind: import_coc.CodeActionKind.SourceFixAll,
        diagnostics: fixInfoDiagnostics,
        command: {
          title,
          command: this.fixAllCommandName
        }
      };
      codeActions.push(sourceFixAllAction);
    }
    return codeActions;
  }
  lint(document) {
    if (document.languageId !== "markdown") {
      return;
    }
    this.diagnosticCollection.clear();
    const results = this.markdownlintWrapper(document);
    if (!results.length) {
      return;
    }
    const diagnostics = [];
    results.forEach((result) => {
      const ruleDescription = result.ruleDescription;
      let message = result.ruleNames.join("/") + ": " + ruleDescription;
      if (result.errorDetail) {
        message += " [" + result.errorDetail + "]";
      }
      const start = import_coc.Position.create(result.lineNumber - 1, 0);
      const end = import_coc.Position.create(result.lineNumber - 1, 0);
      if (result.errorRange) {
        start.character = result.errorRange[0] - 1;
        end.character = start.character + result.errorRange[1];
      }
      const range = import_coc.Range.create(start, end);
      const diagnostic = import_coc.Diagnostic.create(range, message);
      diagnostic.severity = import_coc.DiagnosticSeverity.Warning;
      diagnostic.source = this.source;
      diagnostic.fixInfo = result.fixInfo;
      diagnostics.push(diagnostic);
    });
    this.diagnosticCollection.set(document.uri, diagnostics);
  }
  async fixAll(document) {
    const results = this.markdownlintWrapper(document);
    if (!results.length) {
      return;
    }
    const text = document.getText();
    const fixedText = import_markdownlint_rule_helpers.applyFixes(text, results);
    if (text != fixedText) {
      const doc = import_coc.workspace.getDocument(document.uri);
      const end = import_coc.Position.create(doc.lineCount - 1, doc.getline(doc.lineCount - 1).length);
      const edit = {
        changes: {
          [document.uri]: [import_coc.TextEdit.replace(import_coc.Range.create(import_coc.Position.create(0, 0), end), fixedText)]
        }
      };
      await import_coc.workspace.applyEdit(edit);
    }
  }
};

// src/index.ts
var documentSelector = [
  {
    language: "markdown",
    scheme: "file"
  },
  {
    language: "markdown",
    scheme: "untitled"
  }
];
var documentVersion = 0;
var engine = new MarkdownlintEngine();
var config = import_coc2.workspace.getConfiguration("markdownlint");
function didOpenTextDocument(document) {
  if (config.get("onOpen", true)) {
    engine.lint(document);
  }
}
async function didChangeTextDocument(params) {
  if (!config.get("onChange", true)) {
    return;
  }
  if (params.textDocument.version && documentVersion !== params.textDocument.version) {
    documentVersion = params.textDocument.version;
    const {document} = await import_coc2.workspace.getCurrentState();
    engine.lint(document);
  }
}
async function didSaveTextDocument(document) {
  if (config.get("onSave", true)) {
    engine.lint(document);
  }
}
async function activate(context) {
  await engine.parseConfig();
  context.subscriptions.push(import_coc2.languages.registerCodeActionProvider(documentSelector, engine, "markdownlint"), import_coc2.commands.registerCommand(engine.fixAllCommandName, async () => {
    const {document} = await import_coc2.workspace.getCurrentState();
    engine.fixAll(document);
  }), import_coc2.workspace.onDidOpenTextDocument(didOpenTextDocument), import_coc2.workspace.onDidChangeTextDocument(didChangeTextDocument), import_coc2.workspace.onDidSaveTextDocument(didSaveTextDocument));
  import_coc2.workspace.documents.map((doc) => {
    didOpenTextDocument(doc.textDocument);
  });
}
